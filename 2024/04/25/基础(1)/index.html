<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="马浩珍在 Github 上的个人博客">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="Haojen" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        基础｜Haojen&#39;s blog
        
    </title>

    <link rel="canonical" href="http://haojen.github.io/2024/04/25/基础(1)/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/blog-style.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">

<meta name="generator" content="Hexo 7.1.1"></head>

<style>

    header.intro-header {
        background-image: url('//o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Haojen
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="">


<style>
    
    header.intro-header {
        background-image: url('')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>基础</h1>
                    
                    <span class="meta">
                         作者 maomaomomo
                        <span>
                          日期 2024-04-25
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            基础
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><h2 id="20-一个“-java”源文件中是否可以包含多个类（不是内部类）有什么限制"><a href="#20-一个“-java”源文件中是否可以包含多个类（不是内部类）有什么限制" class="headerlink" title="20. 一个“.java”源文件中是否可以包含多个类（不是内部类）有什么限制?"></a>20. 一个“.java”源文件中是否可以包含多个类（不是内部类）有什么限制?</h2><p>可以；必须只有一个类名与文件名相同。 </p>
<hr>
<h2 id="一个java源文件可以有名称相同，大小写不同的两个类吗"><a href="#一个java源文件可以有名称相同，大小写不同的两个类吗" class="headerlink" title="一个java源文件可以有名称相同，大小写不同的两个类吗?"></a>一个java源文件可以有名称相同，大小写不同的两个类吗?</h2><p>Java源文件可以有名称相同，大小写不同的两个类；</p>
<p>因为Java标识符严格区分大小写</p>
<p>不过在编译过程中，由于window系统不区分大小写，windows将前后编译生成的字节码文件视为同一个（即使这两个文件的命名一个是大写，一个是小写），后编译的类产生的字节码文件将替换掉先编译的类产生的字节码文件</p>
<h2 id="java可不可以使用中文命名"><a href="#java可不可以使用中文命名" class="headerlink" title="java可不可以使用中文命名?"></a>java可不可以使用中文命名?</h2><p>可以 因为jdk使用的是unicode编码(全球统一编码),能够识别中文</p>
<h2 id="java源文件可以不可以数字开头"><a href="#java源文件可以不可以数字开头" class="headerlink" title="java源文件可以不可以数字开头?"></a>java源文件可以不可以数字开头?</h2><p>可以 java源文件不用遵循命名规则（public的类不行）</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><hr>
<h2 id="byte的取值范围是多少，怎么计算出来的？"><a href="#byte的取值范围是多少，怎么计算出来的？" class="headerlink" title="byte的取值范围是多少，怎么计算出来的？"></a>byte的取值范围是多少，怎么计算出来的？</h2><p>一个 byte 类型在计算机中占据一个字节，那么就是 8 bit，所以最大就是 2^7 &#x3D; 1111 1111</p>
<p>Java 中用补码来表示二进制数，补码的最高位是符号位，最高位用 0 表示正数，最高位 1 表示负数</p>
<p>所以正数表示的就是 0111 1111 ，也就是 127。最大负数就是 1111 1111</p>
<p>其中会涉及到两个 0 ，一个 +0 ，一个 -0 ，+0 归为正数，也就是 0 ，-0 归为负数，也就是 -128</p>
<p>所以 byte 的范围就是 -128 – 127。一共是 256 位</p>
<hr>
<h2 id="char-型变量中能不能存储一个中文汉字，为什么？"><a href="#char-型变量中能不能存储一个中文汉字，为什么？" class="headerlink" title="char 型变量中能不能存储一个中文汉字，为什么？"></a>char 型变量中能不能存储一个中文汉字，为什么？</h2><p>char 类型可以存储一个中文汉字</p>
<p>Java中使用的编码是Unicode编码</p>
<p>一个char 类型占2个字节（16 比特），所以放一个中文是没问题的</p>
<p>补充：使用Unicode 意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是 Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务。</p>
<hr>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="&amp; 和 &amp;&amp; 的区别？"></a>&amp; 和 &amp;&amp; 的区别？</h2><table>
<thead>
<tr>
<th>&amp;</th>
<th>&amp;&amp;</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑与</td>
<td>短路与</td>
</tr>
<tr>
<td>当运算符左侧是false,逻辑与右侧继续运算</td>
<td>当运算符左侧是false,逻辑与右侧<strong>不运算</strong>（短路现象）</td>
</tr>
<tr>
<td>可以作为位运算符，进行按位与操作</td>
<td>一定条件下运行性能好</td>
</tr>
</tbody></table>
<h2 id="用最有效率的方法计算2乘以8？"><a href="#用最有效率的方法计算2乘以8？" class="headerlink" title="用最有效率的方法计算2乘以8？"></a>用最有效率的方法计算2乘以8？</h2><p>2 &lt;&lt; 3，将2左移3位</p>
<h2 id="Java移位运算符？"><a href="#Java移位运算符？" class="headerlink" title="Java移位运算符？"></a>Java移位运算符？</h2><ol>
<li>&lt;&lt; ：左移运算符，x &lt;&lt; 1,相当于x乘以2(不溢出的情况下),低位补0 </li>
<li>&gt;&gt; ：带符号右移，x &gt;&gt; 1,相当于x除以2,正数高位补0,负数高位补1 </li>
<li>&gt;&gt;&gt; ：无符号右移，忽略符号位，空位都以0补齐</li>
</ol>
<h2 id="3-0-1-0-3-将会返回什么-true-还是-false"><a href="#3-0-1-0-3-将会返回什么-true-还是-false" class="headerlink" title="3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?"></a>3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?</h2><p>false，因为二进制浮点运算无法精确表示3*0.1的结果（0.30000000000000004）</p>
<h2 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1 有错吗？"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1 有错吗？</h2><p>前者不正确，后者正确</p>
<p>short s1 &#x3D; 1; s1 &#x3D; s1 + 1；由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型</p>
<p> short s1 &#x3D; 1; s1 +&#x3D; 1；可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short)(s1 + 1)；其中有隐含的强制类型转换</p>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="在-Java-中，如何跳出当前的多重嵌套循环？"><a href="#在-Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环？"></a>在 Java 中，如何跳出当前的多重嵌套循环？</h2><ol>
<li><p>标号方式：可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号break语句，即可跳出外层循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ok:<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">        System.out.println(“i=” + i + “,j=” + j);</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">5</span>) </span><br><span class="line">            <span class="keyword">break</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>break跳出当前循环，通过内部跳出条件控制跳出外部循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;; j=&quot;</span>+j);</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">3</span>) &#123;</span><br><span class="line">            i=<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抛出异常也可以跳出多重循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;; j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length &amp;&amp; !found;i++)	&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">        System.out.println(“i=” + i + “,j=” + j);</span><br><span class="line">        <span class="keyword">if</span>(arr[i][j]  == <span class="number">5</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="switch-是否能作用在-byte-上，能否作用在-long-上，能否作用在-String-上"><a href="#switch-是否能作用在-byte-上，能否作用在-long-上，能否作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，能否作用在 long 上，能否作用在 String 上?"></a>switch 是否能作用在 byte 上，能否作用在 long 上，能否作用在 String 上?</h2><table>
<thead>
<tr>
<th>JDK版本</th>
<th>switch（expr）expr允许的参数类型</th>
</tr>
</thead>
<tbody><tr>
<td>早期的 JDK</td>
<td>byte、short、char、int</td>
</tr>
<tr>
<td>JDK1.5开始</td>
<td>byte、short、char、int、枚举类型（enum）</td>
</tr>
<tr>
<td>JDK1.7开始</td>
<td>byte、short、char、int、枚举类型（enum）、字符串（String）</td>
</tr>
</tbody></table>
<p>长整型（long）<strong>是不可以的</strong></p>
<hr>
<h2 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h2><table>
<thead>
<tr>
<th>break</th>
<th>continue</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>结束当前的循环体</td>
<td>结束正在执行的循环 ，继续执行下次循环</td>
<td>程序返回，不再执行下面的代码</td>
</tr>
</tbody></table>
<p>在switch…case语句中，如果没有break,后面的一旦有case匹配成功，后面的case将无条件的向下执行其它的case</p>
<hr>
<h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><h2 id="Math-round-11-5-等于多少？Math-round-11-5-又等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-又等于多少" class="headerlink" title="Math.round(11.5)等于多少？Math.round(- 11.5) 又等于多少?"></a>Math.round(11.5)等于多少？Math.round(- 11.5) 又等于多少?</h2><p>Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11</p>
<p>四舍五入的原理是在参数上加0.5然后进行取整</p>
<hr>
<h2 id="如何取小数点前两位并四舍五入"><a href="#如何取小数点前两位并四舍五入" class="headerlink" title="如何取小数点前两位并四舍五入?"></a>如何取小数点前两位并四舍五入?</h2><p>可用该小数构造 java.math.BigDecimal对象，再利用其 round()方法进行四舍五入到保留小数点后两位，再将其转换为字符串截取最后两位</p>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组有没有length-方法？String有没有length-方法？"><a href="#数组有没有length-方法？String有没有length-方法？" class="headerlink" title="数组有没有length()方法？String有没有length()方法？"></a>数组有没有length()方法？String有没有length()方法？</h2><p>Java中的数组没有length()方法，但是有length属性</p>
<p>String有length()方法。</p>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h2 id="下面-Integer-类型的数值比较输出的结果为？"><a href="#下面-Integer-类型的数值比较输出的结果为？" class="headerlink" title="下面 Integer 类型的数值比较输出的结果为？"></a>下面 Integer 类型的数值比较输出的结果为？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>; </span><br><span class="line">System.out.println(f1 == f2);</span><br><span class="line">System.out.println(f3 == f4);</span><br></pre></td></tr></table></figure>

<p>f1&#x3D;&#x3D;f2的结果是 true，而f3&#x3D;&#x3D;f4 的结果是false</p>
<p>当给Integer 对象赋int 值的时候，会调用 Integer 类的静态方法 valueOf</p>
<p>如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池中的Integer对象</p>
<hr>
<h2 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别?"></a>int 和 Integer 有什么区别?</h2><table>
<thead>
<tr>
<th>区别</th>
<th>int</th>
<th>Integer</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>基础数据类型</td>
<td>包装数据类型</td>
</tr>
<tr>
<td>默认值</td>
<td>0</td>
<td>null</td>
</tr>
<tr>
<td>内存中存储的方式</td>
<td>在内存中直接存储的是数据值</td>
<td>实际存储的是对象引用，（-128,127）之外</td>
</tr>
<tr>
<td>实例化方式</td>
<td>无需实例化即可使用</td>
<td>必须实例化才可以使用</td>
</tr>
<tr>
<td>变量的比较方式</td>
<td>可以使用 &#x3D;&#x3D; 来对比两个变量是否相等</td>
<td>一定要使用 equals 来比较两个变量是否相等</td>
</tr>
</tbody></table>
<hr>
<h2 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h2><p>指某个方法体执行后产生的结果</p>
<hr>
<h2 id="如何将数值型字符转换为数字？"><a href="#如何将数值型字符转换为数字？" class="headerlink" title="如何将数值型字符转换为数字？"></a>如何将数值型字符转换为数字？</h2><p>调用数值类型相应包装类中的方法 parse(String)或 valueOf(String) 即可返回相应基本类型或包装类型数值；</p>
<hr>
<h2 id="如何将数字转换为字符？"><a href="#如何将数字转换为字符？" class="headerlink" title="如何将数字转换为字符？"></a>如何将数字转换为字符？</h2><p>将数字与空字符串相加即可获得其所对应的字符串</p>
<p>基本类型 数字还可调用 String 类中的 valueOf(…)方法返回相应字符串</p>
<p>包装类型数字则可调用其 toString()方法获得相应字符串；</p>
<hr>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="如何理解Java中的泛型是伪泛型？"><a href="#如何理解Java中的泛型是伪泛型？" class="headerlink" title="如何理解Java中的泛型是伪泛型？"></a>如何理解Java中的泛型是伪泛型？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">ArrayList b=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">System.out.println(a.getClass()==b.getClass());</span><br></pre></td></tr></table></figure>

<p>泛型只存在于编译期</p>
<p>JDK 1.5开始，Java在语法上支持泛型，在运行时会进行“类型擦除”，将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型）</p>
<hr>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的作用？"><a href="#注解的作用？" class="headerlink" title="注解的作用？"></a>注解的作用？</h2><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面： 生成文档，通过代码里标识的元数据生成javadoc文档。 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</p>
<hr>
<h2 id="42-注解的常见分类？"><a href="#42-注解的常见分类？" class="headerlink" title="42. 注解的常见分类？"></a>42. 注解的常见分类？</h2><p><strong>Java自带的标准注解</strong>，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。<br><strong>元注解</strong>:元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented @Retention用于标明注解被保留的阶段 @Target用于标明注解使用的范围 @Inherited用于标明注解可继承 @Documented用于标明是否生成javadoc文档 自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</p>
<hr>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="java面向对象的理解？面向对象的特征？"><a href="#java面向对象的理解？面向对象的特征？" class="headerlink" title="java面向对象的理解？面向对象的特征？"></a>java面向对象的理解？面向对象的特征？</h2><p><strong>面向对象是一种思想，是相对于面向过程而言的</strong></p>
<p>对实际的事物进行抽象，再描述其特征与行为，最后组织各种对象的特征和行为，完成业务需求</p>
<ol>
<li>封装：将描述事物的数据和操作封装在一起，形成一个类；被封装的数据和操作只有通过提供的公共方法才能被外界访问，私有属性和方法是无法被访问的，增加数据的安全性</li>
<li>继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承的过程，就是从一般到特殊的过程</li>
<li>多态：一个对象可以指向多种实际类型的现象</li>
</ol>
<hr>
<h2 id="Java中实现多态的机制是什么？"><a href="#Java中实现多态的机制是什么？" class="headerlink" title="Java中实现多态的机制是什么？"></a>Java中实现多态的机制是什么？</h2><p>Java实现多态有三个必要条件：</p>
<ol>
<li>继承：在多态中必须存在有继承关系的子类和父类</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法</li>
</ol>
<p>依靠父类指向子类或接口定义的引用变量指向具体实现类的实例对象。从而实现了一个对象多种形态的特性</p>
<p>其中父类的引用是在程序运行时动态的指向具体的实例，调用该引用的方法时，不是根据引用变量的类型中定义的方法来运行，而是根据具体的实例的方法</p>
<hr>
<h2 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h2><ol>
<li>名字与类名相同</li>
<li>没有返回值，但不能用void声明构造方法</li>
<li>生成类的对象时自动执行，无需调用</li>
</ol>
<hr>
<h2 id="构造器（constructor）是否可被重写（override）？"><a href="#构造器（constructor）是否可被重写（override）？" class="headerlink" title="构造器（constructor）是否可被重写（override）？"></a>构造器（constructor）是否可被重写（override）？</h2><p>构造器不能被继承，因此不能被重写，但可以被重载</p>
<hr>
<h2 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h2><p>super是引用超（父）类（离自己最近的一 个父类）对象的关键字，用来调用父类的成员</p>
<ul>
<li>指向父类对象；如果父类和子类拥有同样名称的字段，super 关键字可以用来访问父类的同名字段</li>
<li>调用父类的方法； super 关键字可以用于方法重写时访问到父类的方法</li>
<li><code>super(参数列表)</code> 可以调用父类的构造方法，但必须在方法的第一行</li>
<li>不能在static修饰的静态方法中使用</li>
</ul>
<hr>
<h2 id="this与super的区别？"><a href="#this与super的区别？" class="headerlink" title="this与super的区别？"></a>this与super的区别？</h2><p><strong>相同点</strong></p>
<ul>
<li>都是Java中的关键字</li>
<li>只能在类的非静态方法中使用，用来访问非静态成员方法和字段</li>
<li>在构造方法中调用时，必须是构造方法的第一条语句，并且不能同时使用</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>this是当前对象的引用，当前对象即调用实例方法的对象，super相当于是子类对象中从父类继承下来部分成员的引用</li>
<li>this可用于区分函数中的形参与成员属性（名称一致的情况），super可用于区分父类与子类有相同成员定义</li>
<li>在非静态成员方法中，this用来访问本来的方法和属性，super用来访问父类继承下来的方法和属性</li>
<li>在构造方法中，this（）用于调用本类构造方法，super（）用于调用父类的构造方法</li>
<li>两种调用不能同时在构造方法中出现，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在</li>
<li>构造方法中一定会存在super（）的调用，用户没有写编译器也会增加，但是this（）用户不写则没有</li>
<li>在底层（字节码层面）this是存在的，指向本对象的指针，但是super是不存在的，super是代码层面的一个关键字，在代码中可以通过super访问子类对象中从基类继承下来的成员，但是代码经过javac编译之后，super就不存在了</li>
</ul>
<hr>
<h2 id="Java中重写和重载有哪些区别？"><a href="#Java中重写和重载有哪些区别？" class="headerlink" title="Java中重写和重载有哪些区别？"></a>Java中重写和重载有哪些区别？</h2><table>
<thead>
<tr>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>在一个类中</td>
<td>在子类和父类中</td>
</tr>
<tr>
<td>同名方法的参数列表不同(参数类型，参数个数以及参数顺序)</td>
<td><strong>同名方法的参数列表都必须相同</strong></td>
</tr>
<tr>
<td>返回类型没有要求</td>
<td><strong>返回类型与父类一致（引用类型要能向上转型）</strong></td>
</tr>
<tr>
<td>访问权限没有要求</td>
<td>相比于重写前的方法，<strong>访问权限不能更低</strong></td>
</tr>
<tr>
<td>异常没有要求</td>
<td>相比于重写前的方法，不能申明更加宽泛的检查型异常</td>
</tr>
<tr>
<td>可以与private的方法彼此之间构成重载的</td>
<td>不能重写父类中声明为private权限的方法</td>
</tr>
<tr>
<td>实现类中的多态（编译时的多态性）</td>
<td>多态的前提（运行时的多态性）</td>
</tr>
</tbody></table>
<hr>
<h2 id="接口和抽象类有哪些区别？"><a href="#接口和抽象类有哪些区别？" class="headerlink" title="接口和抽象类有哪些区别？"></a>接口和抽象类有哪些区别？</h2><table>
<thead>
<tr>
<th></th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td>abstract</td>
<td>interface</td>
</tr>
<tr>
<td>成员方法</td>
<td>除了能有抽象方法外，还可以有实例方法</td>
<td>只能有公共静态常量、抽象方法（jdk8及以上可以有默认方法、静态方法）</td>
</tr>
<tr>
<td>构造器</td>
<td>有构造器方法</td>
<td>没有构造器方法</td>
</tr>
<tr>
<td>使用</td>
<td>需要被类继承（extends），位于类体系的顶层</td>
<td>需要被类实现（implemens）或被接口继承，类实现接口不构成继承体系</td>
</tr>
<tr>
<td>限制</td>
<td>一个类最多继承一个抽象类</td>
<td>一个类可以实现多个接口，一个接口可以继承多个接口</td>
</tr>
<tr>
<td>特点</td>
<td>作为模板</td>
<td>作为标准或某种特性</td>
</tr>
</tbody></table>
<hr>
<h2 id="接口是否可继承（extends）接口-抽象类是否可实现（implements）-接口-抽象类是否可继承具体类（concrete-class）？"><a href="#接口是否可继承（extends）接口-抽象类是否可实现（implements）-接口-抽象类是否可继承具体类（concrete-class）？" class="headerlink" title="接口是否可继承（extends）接口? 抽象类是否可实现（implements） 接口? 抽象类是否可继承具体类（concrete class）？"></a>接口是否可继承（extends）接口? 抽象类是否可实现（implements） 接口? 抽象类是否可继承具体类（concrete class）？</h2><p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类，但前提是具体类必须有明确的构造函数。</p>
<hr>
<h2 id="描述一下值传递和引用传递的区别？"><a href="#描述一下值传递和引用传递的区别？" class="headerlink" title="描述一下值传递和引用传递的区别？"></a>描述一下值传递和引用传递的区别？</h2><p>值传递是指在调用函数时将实际参数复制一份到函数中，这样的话如果函数对其传递过来的形式参数进行修改，将不会影响到实际参数</p>
<p>引用传递是指在调用函数时将对象的地址直接传递到函数中，如果在对形式参数进行修改，将影响到实际参数的值</p>
<hr>
<h2 id="Java中-和equals有哪些区别？"><a href="#Java中-和equals有哪些区别？" class="headerlink" title="Java中&#x3D;&#x3D;和equals有哪些区别？"></a>Java中&#x3D;&#x3D;和equals有哪些区别？</h2><table>
<thead>
<tr>
<th>&#x3D;&#x3D;</th>
<th>equals</th>
</tr>
</thead>
<tbody><tr>
<td>比较运算符</td>
<td>object中的方法</td>
</tr>
<tr>
<td>比较基本类型时比较的是数值是否相等</td>
<td>不能用于基本数据类型数据比较</td>
</tr>
<tr>
<td>比较引用数据类型，比较的是地址</td>
<td>默认情况下equals方法底层使用&#x3D;&#x3D;实现比较内存地址是否相同</td>
</tr>
<tr>
<td></td>
<td>可重写成比较属性是否相等（自定义比较逻辑）如String：比较字符串内容是否相同</td>
</tr>
</tbody></table>
<hr>
<h2 id="hashCode-方法的作用？"><a href="#hashCode-方法的作用？" class="headerlink" title="hashCode()方法的作用？"></a>hashCode()方法的作用？</h2><p>hashCode() 的作用是获取哈希码，也称为散列码</p>
<p>它实际上是返回一个int整数。这个哈希码可以确定该对象在哈希表中的索引位置</p>
<hr>
<h2 id="如果两个对象的hashCode-方法返回的值相同，那么它们是否相等？"><a href="#如果两个对象的hashCode-方法返回的值相同，那么它们是否相等？" class="headerlink" title="如果两个对象的hashCode()方法返回的值相同，那么它们是否相等？"></a>如果两个对象的hashCode()方法返回的值相同，那么它们是否相等？</h2><p>不一定相等，两个不同的对象可能会产生相同的哈希码，这就是所谓的哈希冲突，还需要使用equals()方法进行进一步比较</p>
<hr>
<h2 id="请简述Java中的默认hashCode-方法的实现"><a href="#请简述Java中的默认hashCode-方法的实现" class="headerlink" title="请简述Java中的默认hashCode()方法的实现"></a>请简述Java中的默认hashCode()方法的实现</h2><p>如果对象是一个基本类型，则返回对象的值</p>
<p>如果对象是一个引用类型，则返回对象的对象引用，以对象的地址为基本数据，进行二进制换算</p>
<p>如果对象是一个自定义类型，则返回对象的类型和对象引用</p>
<hr>
<h2 id="请简述Java中的equals-方法的作用"><a href="#请简述Java中的equals-方法的作用" class="headerlink" title="请简述Java中的equals()方法的作用"></a>请简述Java中的equals()方法的作用</h2><p>默认情况下使用&#x3D;&#x3D;比较运算符比较对象的地址是否相等</p>
<p>重写后用于比较对象的内容是否相等（自定义比较逻辑）</p>
<hr>
<h2 id="请简述Java中的Objects-hash-方法的作用"><a href="#请简述Java中的Objects-hash-方法的作用" class="headerlink" title="请简述Java中的Objects.hash()方法的作用"></a>请简述Java中的Objects.hash()方法的作用</h2><p>Objects.hash()方法用于计算对象的哈希码</p>
<p>如果对象是一个基本类型，则返回对象的值</p>
<p>如果对象是一个引用类型，则返回对象的对象引用，以对象的地址为基本数据，进行二进制换算</p>
<p>如果对象是一个自定义类型，则返回对象的类型和对象引用</p>
<hr>
<h2 id="请简述Java中的Objects-toString-方法的作用"><a href="#请简述Java中的Objects-toString-方法的作用" class="headerlink" title="请简述Java中的Objects.toString()方法的作用"></a>请简述Java中的Objects.toString()方法的作用</h2><p>Objects.toString()方法用于将对象转换为一个字符串</p>
<hr>
<h2 id="hashcode方法和equals方法区别？"><a href="#hashcode方法和equals方法区别？" class="headerlink" title="hashcode方法和equals方法区别？"></a>hashcode方法和equals方法区别？</h2><p>equals相等的两个对象他们的hashCode值一定相等，而hashCode值相等的两个对象他们的equals不一定相等，equals可靠性更强</p>
<p>但是重写equals往往有着复杂的比较逻辑，使用equals比较效率比hashCode比较效率更低</p>
<p>因此比较两个对象先使用hashCode方法，若他们的hashCode值不同，则一定不同，再进一步调用equals方法进行比较</p>
<hr>
<h2 id="为什么重写-equals-方法必须重写-hashcode-方法？"><a href="#为什么重写-equals-方法必须重写-hashcode-方法？" class="headerlink" title="为什么重写 equals 方法必须重写 hashcode 方法？"></a>为什么重写 equals 方法必须重写 hashcode 方法？</h2><p>因为Object规范约定如果两个对象通过equals方法比较是相等的，那么它们的hashCode方法结果值也是相等的</p>
<p>重写equals方法而不重写hashCode方法可能会出现equals方法相同的对象hashCode不同，违反了Object规范约定</p>
<hr>
<h2 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</h2><p>不对，如果两个对象x和y满足x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当相同。</p>
<p>Object规范约定：</p>
<ul>
<li>如果两个对象通过equals方法比较是相等的，那么它们的hashCode方法结果值也是相等的</li>
<li>如果两个对象通过equals方法比较是不相等的，那么不要求它们的hashCode方法结果值是相等的</li>
</ul>
<p>如果违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）</p>
<hr>
<h2 id="抽象的-abstract-方法是否可同时是静态的-static-，-是否可同时是本地方法-native-，是否可同时被-synchronized？"><a href="#抽象的-abstract-方法是否可同时是静态的-static-，-是否可同时是本地方法-native-，是否可同时被-synchronized？" class="headerlink" title="抽象的(abstract)方法是否可同时是静态的(static)， 是否可同时是本地方法(native)，是否可同时被 synchronized？"></a>抽象的(abstract)方法是否可同时是静态的(static)， 是否可同时是本地方法(native)，是否可同时被 synchronized？</h2><p>都不能</p>
<ol>
<li>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的</li>
<li>本地方法是由本地代码（如 C++ 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li>
<li>synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的</li>
</ol>
<hr>
<h2 id="final关键字的用法"><a href="#final关键字的用法" class="headerlink" title="final关键字的用法?"></a>final关键字的用法?</h2><ul>
<li>修饰类：表明这个类不能被继承</li>
<li>修饰方法：表示该方法不能被重写</li>
<li>修饰变量：<ul>
<li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改</li>
<li>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。但是它指向的对象的内容是可变的</li>
<li>如果是类成员变量，则必须对其显示赋值（初始化、也可以在每个构造方法或代码块中初始化不同的值）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="60-final和static的区别？"><a href="#60-final和static的区别？" class="headerlink" title="60. final和static的区别？"></a>60. final和static的区别？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        System.out.println(myClass1.i);</span><br><span class="line">        System.out.println(myClass2.i);</span><br><span class="line">        System.out.println(myClass1.j);</span><br><span class="line">        System.out.println(myClass2.j);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">i</span> <span class="operator">=</span> Math.random();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> Math.random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.3222977275463088</span></span><br><span class="line"><span class="number">0.2565532218939688</span></span><br><span class="line"><span class="number">0.36856868882926397</span></span><br><span class="line"><span class="number">0.36856868882926397</span></span><br></pre></td></tr></table></figure>

<p>每次打印的两个j值都是一样的，而i的值却是不同的</p>
<p>从这里就可以知道final和static变量的区别了。static属于类级别的不可变，而final是对象级别的不可变</p>
<hr>
<h2 id="final与finally、finalize-的区别？"><a href="#final与finally、finalize-的区别？" class="headerlink" title="final与finally、finalize 的区别？"></a>final与finally、finalize 的区别？</h2><p>final</p>
<ul>
<li>修饰类表示该类不能被继承</li>
<li>修饰方法表示该方法不能被重写</li>
<li>修饰基本数据类型变量时值无法修改</li>
<li>修饰引用型变量时地址无法修改，但引用变量的内容可以修改</li>
<li>修饰成员变量时必须显式赋值（初始化或在每个构造器方法或代码块中初始值）</li>
</ul>
<p>finally</p>
<ul>
<li>一般作用在异常处理try-catch代码中，表示不管是否出现异常，该代码块都会执行，一般用来关闭资源</li>
<li>有些情况不会执行finally：<ul>
<li>如果在执行try语句块之前已经返回或抛出异常，那么try对应的finally语句不会执行；但若在try语句块中执行return，finally语句还是会执行（撤销return）</li>
<li>在try语句块中执行了System.exit (0) 语句，终止了Java虚拟机的运行</li>
</ul>
</li>
</ul>
<p>finalize</p>
<ul>
<li>Object 类的一个方法，当对象没有被引用时，JVM自动通过垃圾回收器来调用此方法进行回收前的准备工作（new创建的对象都能自动回收）</li>
<li>特殊情况下，需要手动调用finalize，如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接</li>
</ul>
<hr>
<h2 id="静态变量和实例变量区别？"><a href="#静态变量和实例变量区别？" class="headerlink" title="静态变量和实例变量区别？"></a>静态变量和实例变量区别？</h2><ul>
<li>实例变量是属于每个对象的属性，每次创建对象都会为其分配内存空间；而静态变量是属于整个类的属性，在类的加载过程中，JVM只为静态变量分配一次内存空间</li>
<li>实例变量必须创建对象后才能使用；而静态变量则可以直接使用类名来引用</li>
</ul>
<hr>
<h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><ul>
<li>实例方法通过实例对象调用，；而静态方法是通过类自身调用，无需创建对象</li>
<li>实例方法允许访问静态成员与实例成员；而静态方法只允许访问静态成员</li>
</ul>
<hr>
<h2 id="指出下面程序的运行结果？"><a href="#指出下面程序的运行结果？" class="headerlink" title="指出下面程序的运行结果？"></a>指出下面程序的运行结果？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; </span><br><span class="line">    <span class="keyword">static</span>&#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;2&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123; </span><br><span class="line">    <span class="keyword">static</span>&#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;b&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] ars)</span>&#123; </span><br><span class="line">        <span class="type">A</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//执行到此处,结果: 1a2b </span></span><br><span class="line">        ab = <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//执行到此处,结果: 1a2b2b </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>输出结果为 1a2b2b；<br>静态代码块可以看作是类首次加载执行的代码,而对于类加载,首先要执行其基类的构造,再执行其本身的构造</p>
<hr>
<h2 id="访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>访问修饰符public,private,protected,以及不写（默认）时的区别？</h2><table>
<thead>
<tr>
<th>位置</th>
<th>public</th>
<th>protected</th>
<th>默认修饰符（default）</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>类内部</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一个包中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>子类中</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>任意位置</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开 （public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对 子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符 只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p>
<hr>
<h2 id="Java有没有goto？"><a href="#Java有没有goto？" class="headerlink" title="Java有没有goto？"></a>Java有没有goto？</h2><ul>
<li>goto 是Java中的保留字，在目前版本的Java中没有使用</li>
<li>根据James Gosling（Java之 父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列 表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保 留字</li>
</ul>
<hr>
<h2 id="Java-的接口和-C-的虚类的相同和不同处"><a href="#Java-的接口和-C-的虚类的相同和不同处" class="headerlink" title="Java 的接口和 C++的虚类的相同和不同处?"></a>Java 的接口和 C++的虚类的相同和不同处?</h2><p>接口相比抽象类的单继承有更高的灵活性，一个类可以实现多个接口</p>
<hr>
<h2 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗?"></a>String 是最基本的数据类型吗?</h2><ul>
<li>不是；基本数据类型为byte、short、int、long、float、double、char、boolean，其余为引用类型</li>
</ul>
<hr>
<h2 id="String、StringBuffer、StringBuilder区别及使用场景？"><a href="#String、StringBuffer、StringBuilder区别及使用场景？" class="headerlink" title="String、StringBuffer、StringBuilder区别及使用场景？"></a>String、StringBuffer、StringBuilder区别及使用场景？</h2><ul>
<li>String引用的字符串内容是不能被改变的，StringBuffer和StringBuilder表示的字符串对象可以直接进行修改</li>
<li>StringBuilder 是 Java5 中引入的，它和 StringBuffer 的方法完全相同</li>
<li>StringBuilder非线程安全（单线程使用）因为它的所有方法都没有被 synchronized 修饰</li>
<li>String与StringBuffer线程安全（多线程使用）</li>
</ul>
<hr>
<h2 id="String-str-“i”-和String-str-new-String-“1”-一样吗？"><a href="#String-str-“i”-和String-str-new-String-“1”-一样吗？" class="headerlink" title="String str &#x3D; “i” 和String str &#x3D; new String(“1”)一样吗？"></a>String str &#x3D; “i” 和String str &#x3D; new String(“1”)一样吗？</h2><p>不一样</p>
<ul>
<li>String str &#x3D; “i”的方式JVM会将其分配到常量池中</li>
<li>String str &#x3D; new String(“i”)JVM会将其分配到堆内存中</li>
</ul>
<hr>
<h2 id="是否可以继承String类？"><a href="#是否可以继承String类？" class="headerlink" title="是否可以继承String类？"></a>是否可以继承String类？</h2><p>不可以继承String类，String类被final修饰</p>
<hr>
<h2 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s&#x3D;new String(“xyz”);创建了几个字符串对象"></a>String s&#x3D;new String(“xyz”);创建了几个字符串对象</h2><p>两个对象，一个是静态存储区的”xyz”,一个是用 new 创建在堆上的对象。</p>
<hr>
<h2 id="String类的常用方法有哪些？"><a href="#String类的常用方法有哪些？" class="headerlink" title="String类的常用方法有哪些？"></a>String类的常用方法有哪些？</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>indexof()</td>
<td>返回指定字符的的索引</td>
</tr>
<tr>
<td>charAt()</td>
<td>返回指定索引处的字符</td>
</tr>
<tr>
<td>replace()</td>
<td>字符串替换</td>
</tr>
<tr>
<td>trim()</td>
<td>去除字符串两端空格</td>
</tr>
<tr>
<td>splt()</td>
<td>字符串分割，返回分割后的字符串数组</td>
</tr>
<tr>
<td>getBytes()</td>
<td>返回字符串byte类型数组</td>
</tr>
<tr>
<td>length()</td>
<td>返回字符串长度</td>
</tr>
<tr>
<td>toLowerCase()</td>
<td>将字符串转换为小写字母</td>
</tr>
<tr>
<td>toUpperCase()</td>
<td>将字符串转换为大写字母</td>
</tr>
<tr>
<td>substring()</td>
<td>字符串截取</td>
</tr>
<tr>
<td>equals()</td>
<td>比较字符串是否相等</td>
</tr>
</tbody></table>
<hr>
<h2 id="数组有没有-length-方法-String-有没有-length-方法？"><a href="#数组有没有-length-方法-String-有没有-length-方法？" class="headerlink" title="数组有没有 length()方法?String 有没有 length()方法？"></a>数组有没有 length()方法?String 有没有 length()方法？</h2><p>数组没有 length()方法，有 length 的属性</p>
<p>String 有 length()方法。JavaScript 中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java混淆</p>
<hr>
<h2 id="怎样将-GB2312-编码的字符串转换为-ISO-8859-1-编码的字符串？"><a href="#怎样将-GB2312-编码的字符串转换为-ISO-8859-1-编码的字符串？" class="headerlink" title="怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？"></a>怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> newString(s1.getBytes(<span class="string">&quot;GB2312&quot;</span>), <span class="string">&quot;ISO-8859-1&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="String-中的-equals-是如何重写的？"><a href="#String-中的-equals-是如何重写的？" class="headerlink" title="String 中的 equals 是如何重写的？"></a>String 中的 equals 是如何重写的？</h2><ul>
<li>首先比较两个字符串的引用是否相等，如果引用相等的话，直接返回 true</li>
<li>引用不相等再判断被比较的对象是否是 String 的实例，如果不是的话直接返回 false</li>
<li>如果是的话，再比较两个字符串的长度是否相等，如果长度不相等直接返回false</li>
<li>长度如果相同，会比较字符串中的每个字符 是否相等，一旦有一个字符不相等，就会直接返回 false</li>
</ul>
<hr>
<h2 id="如何实现字符串的反转及替换？"><a href="#如何实现字符串的反转及替换？" class="headerlink" title="如何实现字符串的反转及替换？"></a>如何实现字符串的反转及替换？</h2><p>用递归实现字符串反转，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String originStr)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(originStr == <span class="literal">null</span> || originStr.length() &lt;= <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> originStr;</span><br><span class="line">   <span class="keyword">return</span> reverse(originStr.substring(<span class="number">1</span>)) + originStr.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string.substring(from)：相当于从from位置截取到原字符串末尾</p>
<p>charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</p>
<hr>
<h2 id="写一个函数，要求输入一个字符串和一个字符长度，对该字符串进行分隔"><a href="#写一个函数，要求输入一个字符串和一个字符长度，对该字符串进行分隔" class="headerlink" title="写一个函数，要求输入一个字符串和一个字符长度，对该字符串进行分隔"></a>写一个函数，要求输入一个字符串和一个字符长度，对该字符串进行分隔</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String str, <span class="type">int</span> chars)&#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (str.length()+ chars - <span class="number">1</span>)/chars; </span><br><span class="line">    String ret[] = <span class="keyword">new</span> <span class="title class_">String</span>[n]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(i &lt; n-<span class="number">1</span>)&#123; </span><br><span class="line">            ret[i] = str.substring(i*chars , (i+<span class="number">1</span>)*chars); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            ret[i] = str.substring(i*chars); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="写一个函数，2-个参数，1-个字符串，1-个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我-ABC”，4）应该截为“我-AB”，输入（“我ABC-汉-DEF”，6）应该输出为“我-ABC”而不是“我-ABC-汉的半个”"><a href="#写一个函数，2-个参数，1-个字符串，1-个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我-ABC”，4）应该截为“我-AB”，输入（“我ABC-汉-DEF”，6）应该输出为“我-ABC”而不是“我-ABC-汉的半个”" class="headerlink" title="写一个函数，2 个参数，1 个字符串，1 个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我 ABC”，4）应该截为“我 AB”，输入（“我ABC 汉 DEF”，6）应该输出为“我 ABC”而不是“我 ABC+汉的半个”"></a>写一个函数，2 个参数，1 个字符串，1 个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我 ABC”，4）应该截为“我 AB”，输入（“我ABC 汉 DEF”，6）应该输出为“我 ABC”而不是“我 ABC+汉的半个”</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">subString</span><span class="params">(String str, <span class="type">int</span> subBytes)</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">bytes</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用来存储字符串的总字节数 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (bytes == subBytes) &#123; </span><br><span class="line">            <span class="keyword">return</span> str.substring(<span class="number">0</span>, i); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i); </span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">256</span>) &#123; </span><br><span class="line">            bytes += <span class="number">1</span>; <span class="comment">// 英文字符的字节数看作 1 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            bytes += <span class="number">2</span>; <span class="comment">// 中文字符的字节数看作 2 </span></span><br><span class="line">            <span class="keyword">if</span>(bytes - subBytes == <span class="number">1</span>)&#123; </span><br><span class="line">                <span class="keyword">return</span> str.substring(<span class="number">0</span>, i); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> str; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="用程序给出随便大小的-10-个数，序号为-1-10，按从小到大顺序输出，并输出相应的序号"><a href="#用程序给出随便大小的-10-个数，序号为-1-10，按从小到大顺序输出，并输出相应的序号" class="headerlink" title="用程序给出随便大小的 10 个数，序号为 1-10，按从小到大顺序输出，并输出相应的序号"></a>用程序给出随便大小的 10 个数，序号为 1-10，按从小到大顺序输出，并输出相应的序号</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test; </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.Collections; </span><br><span class="line"><span class="keyword">import</span> java.util.Iterator; </span><br><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">import</span> java.util.Random; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomSort</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printRandomBySort</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(); <span class="comment">// 创建随机数生成器 </span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 生成 10 个随机数，并放在集合 list 中 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            list.add(random.nextInt(<span class="number">1000</span>)); </span><br><span class="line">        &#125; </span><br><span class="line">        Collections.sort(list); <span class="comment">// 对集合中的元素进行排序 </span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123; <span class="comment">// 顺序输出排序后集合中的元素 </span></span><br><span class="line">            System.out.println(++count + <span class="string">&quot;: &quot;</span> + it.next()); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        printRandomBySort(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="写一个方法-输入一个文件名和一个字符串-统计这个字符串在这个文件中出现的次数"><a href="#写一个方法-输入一个文件名和一个字符串-统计这个字符串在这个文件中出现的次数" class="headerlink" title="写一个方法,输入一个文件名和一个字符串,统计这个字符串在这个文件中出现的次数"></a>写一个方法,输入一个文件名和一个字符串,统计这个字符串在这个文件中出现的次数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWords</span><span class="params">(String file, String find)</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file); </span><br><span class="line">    <span class="type">int</span> c; </span><br><span class="line">    <span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">while</span> (c == find.charAt(<span class="number">0</span>)) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; find.length(); i++) &#123; </span><br><span class="line">                c = in.read(); </span><br><span class="line">                <span class="keyword">if</span> (c != find.charAt(i)) </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">if</span> (i == find.length() - <span class="number">1</span>) </span><br><span class="line">                    count++; </span><br><span class="line">             &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="介绍一下Object类中的方法？"><a href="#介绍一下Object类中的方法？" class="headerlink" title="介绍一下Object类中的方法？"></a>介绍一下Object类中的方法？</h2><p>Object类提供了如下几个常用方法：<br>Class&lt;?&gt; getClass()：返回该对象的运行时类。<br>boolean equals(Object obj)：判断指定对象与该对象是否相等。<br>int hashCode()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。<br>String toString()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。<br>另外，Object类还提供了wait()、notify()、notifyAll()这几个方法，通过这几个方法可以控制线程的暂停和运行。Object类还提供了一个clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用。</p>
<hr>
<h2 id="83-为什么要重写hashCode-和equals-？"><a href="#83-为什么要重写hashCode-和equals-？" class="headerlink" title="83. 为什么要重写hashCode()和equals()？"></a>83. 为什么要重写hashCode()和equals()？</h2><p>Object类提供的equals()方法默认是用&#x3D;&#x3D;来进行比较的，也就是说只有两个对象是同一个对象时，才能返回相等的结果。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。鉴于这种情况，Object类中equals()方法的默认实现是没有实用价值的，所以通常都要重写。</p>
<hr>
<h2 id="84-Object类中finalize-方法作用？"><a href="#84-Object类中finalize-方法作用？" class="headerlink" title="84. Object类中finalize()方法作用？"></a>84. Object类中finalize()方法作用？</h2><p>垃圾回收器回收对象前,会调用此方法,可以在此方法中做释放资源等清理操作</p>
<hr>
<h2 id="85-System-gc-和-Runtime-gc-作用？"><a href="#85-System-gc-和-Runtime-gc-作用？" class="headerlink" title="85. System.gc() 和 Runtime.gc() 作用？"></a>85. System.gc() 和 Runtime.gc() 作用？</h2><p>这两个方法用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。</p>
<hr>
<h2 id="86-如何格式化日期？"><a href="#86-如何格式化日期？" class="headerlink" title="86.  如何格式化日期？"></a>86.  如何格式化日期？</h2><p>利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的 format(Date)方法可将日期格式化。</p>
<hr>
<h2 id="87-打印昨天的当前时刻。"><a href="#87-打印昨天的当前时刻。" class="headerlink" title="87. 打印昨天的当前时刻。"></a>87. 打印昨天的当前时刻。</h2><p>参考如下源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class YesterdayCurrent&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.add(Calendar.DATE, -1);</span><br><span class="line">        System.out.println(cal.getTime());</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="88-如何在Java中生成随机数？"><a href="#88-如何在Java中生成随机数？" class="headerlink" title="88. 如何在Java中生成随机数？"></a>88. 如何在Java中生成随机数？</h2><p>使用Math.random()可以生成0.1到1.0范围内的随机数字，然后通过数学方法实现生成 符合要求的随机数。</p>
<hr>
<h2 id="89-什么是内部类？"><a href="#89-什么是内部类？" class="headerlink" title="89. 什么是内部类？"></a>89. 什么是内部类？</h2><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是 内部类 。内部类本身就 是类的一个属性，与其他属性定义方式一致。</p>
<hr>
<h2 id="90-内部类的分类有哪些？"><a href="#90-内部类的分类有哪些？" class="headerlink" title="90. 内部类的分类有哪些？"></a>90. 内部类的分类有哪些？</h2><p>内部类可以分为四种： 成员内部类、局部内部类、匿名内部类和静态内部类 。</p>
<hr>
<h2 id="91-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"><a href="#91-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制" class="headerlink" title="91. 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"></a>91. 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制</h2><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<hr>
<h2 id="92-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以-实现接口"><a href="#92-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以-实现接口" class="headerlink" title="92. Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以 实现接口"></a>92. Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以 实现接口</h2><p>可以继承其他类或实现其他接口，在 Swing 编程中常用此方式来实现事件监听和回调</p>
<hr>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="93-简单概述下异常。"><a href="#93-简单概述下异常。" class="headerlink" title="93. 简单概述下异常。"></a>93. 简单概述下异常。</h2><p>Throwable 是 Java 语言中所有错误与异常的超类。<br>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。<br>Exception 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220920/1663637207@de13957bbd8247bc2511ec86fba6c130.png" alt="img"></p>
<p><strong>运行时异常</strong> 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。<br><strong>非运行时异常 （编译异常）</strong>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<hr>
<h2 id="94-异常如何处理的？"><a href="#94-异常如何处理的？" class="headerlink" title="94. 异常如何处理的？"></a>94. 异常如何处理的？</h2><p>异常需要处理的时机分为编译时异常(也叫受控异常)也叫 CheckedException 和运行时异常(也叫非受控异常)也叫 UnCheckedException。Java认为Checked异常都是可以被处理的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked 异常，该程序在编译时就会发生错误无法编译。这体现了Java 的设计哲学：没有完善错误处理的代码根本没有机会被执行。<br>对Checked异常处理方法有两种：<br>● 第一种：当前方法知道如何处理该异常，则用try…catch块来处理该异常。<br>● 第二种：当前方法不知道如何处理，则在定义该方法时声明抛出该异常。<br>运行时异常只有当代码在运行时才发行的异常，编译的时候不需要try…catch。Runtime如除数是0和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。</p>
<hr>
<h2 id="95-异常处理中的throws、throw、try、catch、finally-分别如何使用？"><a href="#95-异常处理中的throws、throw、try、catch、finally-分别如何使用？" class="headerlink" title="95. 异常处理中的throws、throw、try、catch、finally 分别如何使用？"></a>95. 异常处理中的throws、throw、try、catch、finally 分别如何使用？</h2><p>Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。<br>一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try 用来指定一块预防所有“异常”的程序；catch 子句紧跟在 try 块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws 用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try 语句保护其他代码。每当遇到一个 try 语句，“异常”的框架就放到栈上面，直到所有的try 语句都完成。如果下一级的 try 语句没有对某种”异常”进行处理，栈就会展开，直到遇到有处理这种”异常”的 try 语句。</p>
<hr>
<h2 id="96-try-里有一个-return-语句，那么紧跟在这个-try-后的-finally-里的-code-会不会被执行，什么时候被执行，在-return-前还是后"><a href="#96-try-里有一个-return-语句，那么紧跟在这个-try-后的-finally-里的-code-会不会被执行，什么时候被执行，在-return-前还是后" class="headerlink" title="96. try{}里有一个 return 语句，那么紧跟在这个 try 后的 finally{}里的 code 会不会被执行，什么时候被执行，在 return 前还是后?"></a>96. try{}里有一个 return 语句，那么紧跟在这个 try 后的 finally{}里的 code 会不会被执行，什么时候被执行，在 return 前还是后?</h2><p>会执行，在方法返回调用者前执行。Java 允许在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。</p>
<hr>
<h2 id="97-Error-和-Exception-有什么区别？"><a href="#97-Error-和-Exception-有什么区别？" class="headerlink" title="97. Error 和 Exception 有什么区别？"></a>97. Error 和 Exception 有什么区别？</h2><p>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<hr>
<h2 id="98-异常编程题：下面代码的输出结果？"><a href="#98-异常编程题：下面代码的输出结果？" class="headerlink" title="98. 异常编程题：下面代码的输出结果？"></a>98. 异常编程题：下面代码的输出结果？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="keyword">try</span> &#123; </span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：代码走到第3行的时候遇到了一个MathException，这时第4行的代码就不会执行了，代码直接跳转到catch语句中，走到第 6 行的时候，异常机制有一个原则：如果在catch中遇到了return或者异常等能使该函数终止的话那么有finally就必须先执行完finally代码块里面的代码然后再返回值。因此代码又跳到第8行，可惜第8行是一个return语句，那么这个时候方法就结束了，因此第6行的返回结果就无法被真正返回。因此上面返回值是3。</p>
<hr>
<h2 id="99-类-Example-A-继承-Exception，类-ExampleB-继承-Example-A"><a href="#99-类-Example-A-继承-Exception，类-ExampleB-继承-Example-A" class="headerlink" title="99. 类 Example A 继承 Exception，类 ExampleB 继承 Example A"></a>99. 类 Example A 继承 Exception，类 ExampleB 继承 Example A</h2><p>有如下代码片断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExampleB</span>(“b”)；</span><br><span class="line">&#125;<span class="keyword">catch</span>（ExampleA e）&#123;</span><br><span class="line">    System.out.printfln（“ExampleA”）；</span><br><span class="line">&#125;<span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">    System.out.printfln（“Exception”）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的内容应该是：ExampleA</p>
<hr>
<h2 id="100-常见的异常有哪些？"><a href="#100-常见的异常有哪些？" class="headerlink" title="100. 常见的异常有哪些？"></a>100. 常见的异常有哪些？</h2><p>●java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象。<br>● java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。<br>● java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。<br>● java.lang.ClassCastException 数据类型转换异常。<br>● java.lang.SQLException SQL异常，常见于操作数据库时的 SQL 语句错误。</p>
<hr>
<h2 id="101-throw-和-throws-的区别？"><a href="#101-throw-和-throws-的区别？" class="headerlink" title="101. throw 和 throws 的区别？"></a>101. throw 和 throws 的区别？</h2><p>● throw：<br>throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。<br>throw是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行throw一定是抛出了某种异常。<br>● throws：<br>throws语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。<br>throws主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。</p>
<hr>
<h2 id="102-Java-7-的-try-with-resource"><a href="#102-Java-7-的-try-with-resource" class="headerlink" title="102. Java 7 的 try-with-resource?"></a>102. Java 7 的 try-with-resource?</h2><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">automaticallyCloseResource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="103-异常的底层？"><a href="#103-异常的底层？" class="headerlink" title="103. 异常的底层？"></a>103. 异常的底层？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatch</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javap来分析这段代码（需要先使用javac编译）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//javap -c Main</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatch</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: goto          <span class="number">11</span></span><br><span class="line">       <span class="number">6</span>: astore_0</span><br><span class="line">       <span class="number">7</span>: aload_0</span><br><span class="line">       <span class="number">8</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">      <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>     <span class="number">6</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure>

<p>异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下<br>1)from 可能发生异常的起始点<br>2)to可能发生异常的结束点<br>3)target上述from和to之前发生异常后的异常处理者的位置<br>4)type异常处理者处理的异常的类信息</p>
<hr>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="104-什么是IO流？"><a href="#104-什么是IO流？" class="headerlink" title="104. 什么是IO流？"></a>104. 什么是IO流？</h2><p>IO流就是以流的方式进行输入输出。主要用来处理设备之间的传输，文件的上传，下载和复制。<br>流分输入和输出，输入流从文件中读取数据存储到进程中，输出流从进程中读取数据然后写入到目标文件。</p>
<hr>
<h2 id="105-Java-中有几种类型的流？"><a href="#105-Java-中有几种类型的流？" class="headerlink" title="105. Java 中有几种类型的流？"></a>105. Java 中有几种类型的流？</h2><p>按照流的方向：输入流（inputStream）和输出流（outputStream）<br>按照实现功能分：节点流（可以从或向一个特定的地方（节点）读写数据。如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如 BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。）<br>按照处理数据的单位： 字节流和字符流。字节流继承于 InputStream 和 OutputStream， 字符流继承于Reader 和 Writer 。</p>
<hr>
<h2 id="106-字节流和字符流的区别？"><a href="#106-字节流和字符流的区别？" class="headerlink" title="106. 字节流和字符流的区别？"></a>106. 字节流和字符流的区别？</h2><p>1)字节流读取的时候，读到一个字节就返回一个字节；字符流读取的时候会读到一个或多个字节（这个要根据字符流中编码设置，一般中文对应的字节数是两个，在UTF-8码表中是3个字节）<br>2)字节流可以处理所有类型数据，如：图片，MP3，AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都用字节流。<br>3)字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件。<br>案例1：在写操作的过程中，没有关闭字节流操作，但是文件中也依然存在了输出的内容代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="comment">// 第1步：使用File类找到一个文件 </span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>); <span class="comment">// 声明File 对象 </span></span><br><span class="line">    <span class="comment">// 第2步：通过子类实例化父类对象 </span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f); </span><br><span class="line">    <span class="comment">// 第3步：进行写操作 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!!!&quot;</span>; <span class="comment">// 准备一个字符串 </span></span><br><span class="line">    <span class="type">byte</span> b[] = str.getBytes(); <span class="comment">// 字符串转byte数组 </span></span><br><span class="line">    out.write(b); <span class="comment">// 将内容输出 </span></span><br><span class="line">    <span class="comment">// 第4步：关闭输出流 </span></span><br><span class="line">    <span class="comment">// out.close();</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>案例2：在写操作的过程中，没有关闭字符流操作，发现文件中没有任何内容输出。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;         </span><br><span class="line">    <span class="comment">// 第1步：使用File类找到一个文件    </span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);<span class="comment">// 声明File 对象    </span></span><br><span class="line">    <span class="comment">// 第2步：通过子类实例化父类对象    </span></span><br><span class="line">    <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f);            </span><br><span class="line">    <span class="comment">// 第3步：进行写操作    </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!!!&quot;</span>; <span class="comment">// 准备一个字符串    </span></span><br><span class="line">    out.write(str); <span class="comment">// 将内容输出</span></span><br><span class="line">    out.flush();     </span><br><span class="line">    <span class="comment">// 第4步：关闭输出流    </span></span><br><span class="line">    <span class="comment">// out.close();  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这是因为字符流操作时使用了缓冲区，而在关闭字符流时会强制性地将缓冲区中的内容进行输出，但是如果程序没有关闭，则缓冲区中的内容是无法输出的。当然如果在不关闭字符流的情况下也可以使用Writer类中的flush()强制性的清空缓存，从而将字符流的内容全部输出。</p>
<hr>
<h2 id="107-怎么样把字节流转换成字符流-说出它的步骤？"><a href="#107-怎么样把字节流转换成字符流-说出它的步骤？" class="headerlink" title="107. 怎么样把字节流转换成字符流,说出它的步骤？"></a>107. 怎么样把字节流转换成字符流,说出它的步骤？</h2><p>解题思路：把字节流转成字符流就要用到适配器模式，需要用到OutputStreamWriter。它继承了Writer接口，但要创建它必须在构造函数中传入一个OutputStream的实例，OutputStreamWriter的作用也就是将OutputStream适配到Writer。它实现了Reader接口，并且持有了InputStream的引用。利用转换流OutputStreamWriter.创建一个字节流对象,将其作为参数传入转换流OutputStreamWriter中得到字符流对象.</p>
<hr>
<h2 id="108-什么是序列化？"><a href="#108-什么是序列化？" class="headerlink" title="108. 什么是序列化？"></a>108. 什么是序列化？</h2><p>序列化是指把对象转换为字节序列的过程，序列化后的字节流保存了对象的状态以及相关的描述信息，从而方便在网络上传输或者保存在本地文件中，达到对象状态的保存与重建的目的。<br>反序列化:客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。<br>序列化的优势：一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。三是通过序列化在进程间传递对象；</p>
<hr>
<h2 id="109-IO如何实现序列化和反序列化？"><a href="#109-IO如何实现序列化和反序列化？" class="headerlink" title="109. IO如何实现序列化和反序列化？"></a>109. IO如何实现序列化和反序列化？</h2><p>(1)java.io.ObjectOutputStream：表示对象输出流；它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；<br>(2)java.io.ObjectInputStream：表示对象输入流；它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回；<br>注意：只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！</p>
<p><strong>序列化和反序列化的示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerialDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">	    <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xuliugen&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">		<span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName()+ <span class="string">&quot; &quot;</span> + </span><br><span class="line">	    user2.getPassword() + <span class="string">&quot; &quot;</span> + user2.getSex());</span><br><span class="line">        <span class="comment">//反序列化的输出结果为：xuliugen 123456 male</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">//全参构造方法、get和set方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="110-PrintStream、BufferedWriter、PrintWriter-的比较？"><a href="#110-PrintStream、BufferedWriter、PrintWriter-的比较？" class="headerlink" title="110. PrintStream、BufferedWriter、PrintWriter 的比较？"></a>110. PrintStream、BufferedWriter、PrintWriter 的比较？</h2><p>\1. PrintStream 类的输出功能非常强大，通常如果需要输出文本内容，都应该将输出流包装成PrintStream 后进行输出。它还提供其他两项功能。与其他输出流不同，PrintStream 永远不会抛出 IOException；而是，异常情况仅设置可通过 checkError 方法测试的内部标志。另外，为了自动刷新，可以创建一个 PrintStream<br>2.BufferedWriter:将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过 write()方法可以将获取到的字符输出，然后通过 newLine()进行换行操作。BufferedWriter 中的字符流必须通过调用 flush 方法才能将其刷出去。并且 BufferedWriter 只能对字符流进行操作。如果要对字节流操作，则使用 BufferedInputStream<br>3.PrintWriter 的 println 方法自动添加换行，不会抛异常，若关心异常，需要调用 checkError方法看是否有异常发生，PrintWriter 构造方法可指定参数，实现自动刷新缓存(autoflush)。</p>
<hr>
<h2 id="111-如果我要对字节流进行大量的从硬盘读取-要用那个流-为什么？"><a href="#111-如果我要对字节流进行大量的从硬盘读取-要用那个流-为什么？" class="headerlink" title="111. 如果我要对字节流进行大量的从硬盘读取,要用那个流,为什么？"></a>111. 如果我要对字节流进行大量的从硬盘读取,要用那个流,为什么？</h2><p>因为明确说了是对字节流的读取，所以肯定是InputStream或者他的子类，又因为要大量读取，肯定要考虑到高效的问题，自然想到缓冲流BufferedInputStream。<br>原因：BufferedInputStream是InputStream的缓冲流，使用它可以防止每次读取数据时进行实际的写操作，代表着使用缓冲区。不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多！并且也可以减少对磁盘的损伤。</p>
<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="112-什么是集合"><a href="#112-什么是集合" class="headerlink" title="112. 什么是集合?"></a>112. 什么是集合?</h2><p>集合就是一个放数据的容器，准确的说是放数据对象引用的容器;集合类存放的都是对象的引用，而不是对象的本身;集合类型主要有3种：set(集）、list(列表）和map(映射)。</p>
<hr>
<h2 id="113-集合框架中的泛型有什么优点？"><a href="#113-集合框架中的泛型有什么优点？" class="headerlink" title="113. 集合框架中的泛型有什么优点？"></a>113. 集合框架中的泛型有什么优点？</h2><p>Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<hr>
<h2 id="114-Iterator是什么？"><a href="#114-Iterator是什么？" class="headerlink" title="114. Iterator是什么？"></a>114. Iterator是什么？</h2><p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。</p>
<hr>
<h2 id="115-集合和数组的区别"><a href="#115-集合和数组的区别" class="headerlink" title="115. 集合和数组的区别?"></a>115. 集合和数组的区别?</h2><p>数组是固定长度的；集合可变长度的。<br>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。<br>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</p>
<hr>
<h2 id="116-常用的集合类有哪些？"><a href="#116-常用的集合类有哪些？" class="headerlink" title="116. 常用的集合类有哪些？"></a>116. 常用的集合类有哪些？</h2><p>Map接口和Collection接口是所有集合框架的父接口：<br>Collection接口的子接口包括：Set接口和List接口<br>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等<br>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等<br>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</p>
<hr>
<h2 id="117-Collection-和-Collections-有什么区别？"><a href="#117-Collection-和-Collections-有什么区别？" class="headerlink" title="117. Collection 和 Collections 有什么区别？"></a>117. Collection 和 Collections 有什么区别？</h2><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。<br>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>
<hr>
<h2 id="118-Set和List的区别？"><a href="#118-Set和List的区别？" class="headerlink" title="118. Set和List的区别？"></a>118. Set和List的区别？</h2><p>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。都可以存储null值，但是set不能重复所以最多只能有一个空元素。<br>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。<br>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。</p>
<hr>
<h2 id="119-Arraylist与-LinkedList-异同？"><a href="#119-Arraylist与-LinkedList-异同？" class="headerlink" title="119. Arraylist与 LinkedList 异同？"></a>119. Arraylist与 LinkedList 异同？</h2><p>1)Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；<br>2)ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。插入末尾还好，如果是中间，则（add(int index, E element)）接近O（n）；LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。<br>3)LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。所以ArrayList随机访问快，插入慢；LinkedList随机访问慢，插入快。<br>4)ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<hr>
<h2 id="120-ArrayList和Vector有何异同点？"><a href="#120-ArrayList和Vector有何异同点？" class="headerlink" title="120. ArrayList和Vector有何异同点？"></a>120. ArrayList和Vector有何异同点？</h2><p>ArrayList和Vector在很多时候都很类似。<br>(1)两者都是基于索引的，内部由一个数组支持。<br>(2)两者维护插入的顺序，我们可以根据插入顺序来获取元素。<br>(3)ArrayList和Vector的迭代器实现都是fail-fast的。<br>(4)ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。<br>以下是ArrayList和Vector的不同点。<br>(1)Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。<br>(2)ArrayList比Vector快，它因为有同步，不会过载。<br>(3)ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>
<hr>
<h2 id="121-遍历一个List有哪些不同的方式？"><a href="#121-遍历一个List有哪些不同的方式？" class="headerlink" title="121. 遍历一个List有哪些不同的方式？"></a>121. 遍历一个List有哪些不同的方式？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//使用for-each循环</span></span><br><span class="line"><span class="keyword">for</span>(String obj : strList)&#123;</span><br><span class="line">  System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//using iterator</span></span><br><span class="line">Iterator&lt;String&gt; it = strList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">  System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="122-HashSet如何检查重复？"><a href="#122-HashSet如何检查重复？" class="headerlink" title="122. HashSet如何检查重复？"></a>122. HashSet如何检查重复？</h2><p>当把对象加入到HashSet中时，HashSet会先计算对象的hashCode值来判断对象加入的下标位置，同时也会与其他的对象的hashCode进行比较，如果没有相同的，就直接插入数据；如果有相同的，就进一步使用equals来进行比较对象是否相同，如果相同，就不会加入成功。</p>
<hr>
<h2 id="123-HashMap如何遍历？"><a href="#123-HashMap如何遍历？" class="headerlink" title="123. HashMap如何遍历？"></a>123. HashMap如何遍历？</h2><p>1.使用foreach循环遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;study&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;day&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;up&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;:&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用foreach迭代键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;study&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;day&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;up&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String key : hashMap.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String value : hashMap.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.使用迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;study&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;day&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;up&quot;</span>);</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = hashMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; next = iterator.next();</span><br><span class="line">    System.out.println(next.getKey()+<span class="string">&quot;:&quot;</span>+next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.使用lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;study&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;day&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;up&quot;</span>);</span><br><span class="line">hashMap.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="124-HashMap-和-Hashtable-的区别"><a href="#124-HashMap-和-Hashtable-的区别" class="headerlink" title="124. HashMap 和 Hashtable 的区别?"></a>124. HashMap 和 Hashtable 的区别?</h2><p>相同点：<br>都是实现来Map接口（hashTable还实现了Dictionary 抽象类）。<br>不同点：<br>\1. 历史原因:Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引进的 Map 接口<br>的一个实现，HashMap把Hashtable 的contains方法去掉了，改成containsvalue 和containsKey。因为contains方法容易让人引起误解。<br>\2. 同步性:Hashtable 的方法是 Synchronize 的，线程安全；而 HashMap 是线程不安全的，不是同步的。所以只有一个线程的时候使用hashMap效率要高。<br>\3. 值：HashMap对象的key、value值均可为null。HahTable对象的key、value值均不可为null。<br>\4. 容量：HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。<br>\5. HashMap扩容时是当前容量翻倍即:capacity * 2，Hashtable扩容时是容量翻倍+1 即:capacity * 2+1。</p>
<hr>
<h2 id="125-HashSet-和-HashMap-区别？"><a href="#125-HashSet-和-HashMap-区别？" class="headerlink" title="125. HashSet 和 HashMap 区别？"></a>125. HashSet 和 HashMap 区别？</h2><p>HashSet 底层就是基于 HashMap 实现的。只不过HashSet里面的HashMap所有的value都是同一个Object而已，因此HashSet也是非线程安全的。</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220826/1661484027@1dcee0974910ac94ad1a2bf44a5dd6ed.png" alt="img"></p>
<hr>
<h2 id="126-HaspMap与TreeMap的区别？"><a href="#126-HaspMap与TreeMap的区别？" class="headerlink" title="126. HaspMap与TreeMap的区别？"></a>126. HaspMap与TreeMap的区别？</h2><p>\1. HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。<br>\2. 在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。</p>
<hr>
<h2 id="127-ArrayList自动扩容？"><a href="#127-ArrayList自动扩容？" class="headerlink" title="127. ArrayList自动扩容？"></a>127. ArrayList自动扩容？</h2><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过ensureCapacity(int minCapacity)方法来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。 数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p>
<hr>
<h2 id="128-ArrayList的Fail-Fast机制？"><a href="#128-ArrayList的Fail-Fast机制？" class="headerlink" title="128. ArrayList的Fail-Fast机制？"></a>128. ArrayList的Fail-Fast机制？</h2><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="13-Java-中的反射是什么意思？有哪些应用场景？"><a href="#13-Java-中的反射是什么意思？有哪些应用场景？" class="headerlink" title="13. Java 中的反射是什么意思？有哪些应用场景？"></a>13. Java 中的反射是什么意思？有哪些应用场景？</h2><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName,这种方式来控制类的加载，该方法会返回一个 Class 对象。<br>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：<br>(1)Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；<br>(2)Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；<br>(3)Constructor ：可以用 Constructor 创建新的对象。<br>应用举例：工厂模式，使用反射机制，根据全限定类名获得某个类的 Class 实例。</p>
<hr>
<h2 id="14-什么是反射？"><a href="#14-什么是反射？" class="headerlink" title="14. 什么是反射？"></a>14. 什么是反射？</h2><p>反射是Java中用于动态获取类的属性和方法、动态调用对象的属性和方法的功能</p>
<p>对于任意一个类，都能够知道这个类的所有属性和方法</p>
<p>对于任意一个对象，都能够调用它的任意一个方法和属性</p>
<hr>
<h2 id="15-反射的范围？"><a href="#15-反射的范围？" class="headerlink" title="15. 反射的范围？"></a>15. 反射的范围？</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>用来描述类本身</td>
</tr>
<tr>
<td>Packge</td>
<td>用来描述类所属的包</td>
</tr>
<tr>
<td>Field</td>
<td>用来描述类中的属性</td>
</tr>
<tr>
<td>Method</td>
<td>用来描述类中的方法</td>
</tr>
<tr>
<td>Constructor</td>
<td>用来描述类中的构造方法</td>
</tr>
<tr>
<td>Annotation</td>
<td>用来描述类中的注解</td>
</tr>
</tbody></table>
<hr>
<h2 id="16-如何获取Class？"><a href="#16-如何获取Class？" class="headerlink" title="16. 如何获取Class？"></a>16. 如何获取Class？</h2><ol>
<li>Class clazz&#x3D;class.forName(“包名.类名”)</li>
<li>Class clazz&#x3D;类名.class;</li>
<li>Class clazz&#x3D;对象.getClass();</li>
</ol>
<hr>
<h2 id="17-反射中常用的方法"><a href="#17-反射中常用的方法" class="headerlink" title="17. 反射中常用的方法?"></a>17. 反射中常用的方法?</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int result&#x3D;clazz.getModifiers();</td>
<td>获取类的权限修饰符</td>
</tr>
<tr>
<td>string name&#x3D;clazz.getName()</td>
<td>获取名字</td>
</tr>
<tr>
<td>Packge p&#x3D;clazz.getPackge()</td>
<td>获取包名</td>
</tr>
<tr>
<td>clazz.getConstructor([String.class]);</td>
<td>寻找clazz中无参数构造方法</td>
</tr>
<tr>
<td>clazz.newInstance([参数])</td>
<td>执行构造方法创建对象</td>
</tr>
<tr>
<td>Field c&#x3D;clazz.getFields()</td>
<td>获得某个类的所有的公共（public）的字段，包括父类中的字段</td>
</tr>
<tr>
<td>Field c&#x3D;clazz.getDeclaredFields()</td>
<td>获得某个类的所有声明的字段，即包括public、private和 protected，但是不包括父类的声明字段</td>
</tr>
</tbody></table>
<hr>
<h2 id="18-反射的利与弊"><a href="#18-反射的利与弊" class="headerlink" title="18. 反射的利与弊?"></a>18. 反射的利与弊?</h2><ol>
<li><p>优点：</p>
<ol>
<li><p>动态性和灵活性<br>反射使得程序可以在运行时获取操作类、方法、字段等信息，而不需要在编译时固定类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的全限定名可以配置在xml或properties文件中，便于维护</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="comment">//调用对象方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;myMethod&quot;</span>);</span><br><span class="line">method.invoke(instance);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通用性<br>反射机制是通用的，适用于任何Java类。这使得您可以编写通用的代码，以处理不同类型的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持第三方插件，用于扩展未知应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printFieldValues</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(field.getName() + <span class="string">&quot;: &quot;</span> + field.get(obj));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>框架和库的实现<br>反射广泛用于Java框架和库的实现，例如Spring、Hibernate、JUnit等。这些框架需要在运行时获取和操作类信息以提供灵活的功能</p>
</li>
<li><p>动态代理<br>反射允许创建动态代理，用于在运行时生成代理对象以实现特定接口的方法。这对AOP（面向切面编程）非常有用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在方法执行前后执行额外的逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><p>性能开销<br>反射通常比直接调用代码更慢，因为它需要在运行时进行类加载、方法查找方法以及动态调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;myMethod&quot;</span>);</span><br><span class="line">method.invoke(instance);</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型安全问题<br>使用反射可以绕过编译时类型检查，这可能导致类型安全问题。如果不小心操作对象的类型，可能会引发ClassCastException等异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;myMethod&quot;</span>);</span><br><span class="line"><span class="comment">// 期望 myMethod 返回一个 String，但这是在运行时才知道的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(instance); <span class="comment">// 可能引发ClassCastException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可维护性问题<br>由于反射允许操作私有方法和字段，这可能导致代码不可读和难以维护。此外，类结构的更改可能导致反射代码无法正常工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;myField&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(instance, newValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>安全性问题<br>反射允许执行敏感操作，可能会导致安全漏洞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;doDangerousOperation&quot;</span>);</span><br><span class="line">method.invoke(instance); <span class="comment">// 可能引发安全问题</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<hr>
<h2 id="19-getName、getCanonicalName与getSimpleName的区别"><a href="#19-getName、getCanonicalName与getSimpleName的区别" class="headerlink" title="19. getName、getCanonicalName与getSimpleName的区别?"></a>19. getName、getCanonicalName与getSimpleName的区别?</h2><table>
<thead>
<tr>
<th>getName</th>
<th>getSimpleName</th>
<th>getCanonicalName</th>
</tr>
</thead>
<tbody><tr>
<td>类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName</td>
<td>只获取类名</td>
<td>返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了</td>
</tr>
</tbody></table>
<hr>
<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-什么是JDBC？"><a href="#1-什么是JDBC？" class="headerlink" title="1. 什么是JDBC？"></a>1. 什么是JDBC？</h2><p>熟练度：☆   </p>
<ol>
<li>JDBC的全称是Java DataBase Connectivity</li>
<li>它是由一组用Java语言编写的类和接口组成（java.sql 和javax.sql）的标准Java API</li>
<li>用于Java编程语言与数据库连接、执⾏SQL查询，存储过程，并处理返回的结果</li>
<li>JDBC接⼝让Java程序和JDBC驱动实现了松耦合，对于多种关系型数据库提供统一访问，使得切换不同的数据库变得更加简单</li>
</ol>
<hr>
<h2 id="2-如何理解Class-forName-com-mysql-cj-jdbc-Driver-？"><a href="#2-如何理解Class-forName-com-mysql-cj-jdbc-Driver-？" class="headerlink" title="2. 如何理解Class.forName(com.mysql.cj.jdbc.Driver)？"></a>2. 如何理解<code>Class.forName(com.mysql.cj.jdbc.Driver)</code>？</h2><p>熟练度：☆</p>
<ol>
<li><code>com.mysql.cj.jdbc.Driver</code>是Driver驱动所在的位置</li>
<li><code>Class.forName()</code>是一个反射，但是他没有返回一个Class对象，而是初始化了Driver类，执行其中的静态代码块，即<code>DriverManager.registerDriver(new Driver());</code>注册驱动</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-JDBC的DriverManager是用来做什么的？"><a href="#3-JDBC的DriverManager是用来做什么的？" class="headerlink" title="3. JDBC的DriverManager是用来做什么的？"></a>3. JDBC的DriverManager是用来做什么的？</h2><p>熟练度：☆</p>
<p>DriverManager是一个工厂类，我们可以通过它来注册JDBC驱动，当JDBC的Driver类被加载进来时，它将被自动注册</p>
<hr>
<h2 id="4-说下JDBC连接数据库的6个步骤？"><a href="#4-说下JDBC连接数据库的6个步骤？" class="headerlink" title="4. 说下JDBC连接数据库的6个步骤？"></a>4. 说下JDBC连接数据库的6个步骤？</h2><p>熟练度：☆</p>
<ol>
<li>注册驱动</li>
<li>获取连接</li>
<li>创建一个Statement语句对象</li>
<li>执行SQL语句</li>
<li>处理结果集</li>
<li>关闭资源</li>
</ol>
<hr>
<h2 id="5-Statement-、PreparedStatement和CallableStatement的区别？"><a href="#5-Statement-、PreparedStatement和CallableStatement的区别？" class="headerlink" title="5. Statement 、PreparedStatement和CallableStatement的区别？"></a>5. Statement 、PreparedStatement和CallableStatement的区别？</h2><p>熟练度：☆</p>
<table>
<thead>
<tr>
<th>Statement</th>
<th>PreparedStatement</th>
<th>CallableStatement</th>
</tr>
</thead>
<tbody><tr>
<td>一般用于执行固定的没有参数的SQL</td>
<td>继承于 Statement，一般用于执行有？参数预编译的SQL语句。可以防止SQL注入，安全性高于Statement</td>
<td>适用于执行存储过程</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-execute，executeQuery，executeUpdate的区别是什么？"><a href="#6-execute，executeQuery，executeUpdate的区别是什么？" class="headerlink" title="6. execute，executeQuery，executeUpdate的区别是什么？"></a>6. execute，executeQuery，executeUpdate的区别是什么？</h2><p>熟练度：</p>
<table>
<thead>
<tr>
<th></th>
<th>execute(String query)</th>
<th>executeQuery(String query)</th>
<th>executeUpdate(String query)</th>
</tr>
</thead>
<tbody><tr>
<td>应用</td>
<td>⽤来执⾏任意的SQL查询</td>
<td>⽤来执⾏select查询语句</td>
<td>⽤来执⾏insert或者update&#x2F;delete（DML）语句</td>
</tr>
<tr>
<td>执行</td>
<td>如果查询的结果是⼀个ResultSet，这个⽅法就返回true。如果结果不是ResultSet，⽐如insert或者update查询，它就会返回false</td>
<td>返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。如果传进来的是insert或者update语句，它会抛出错误信息为“executeQuery method can not be used for update”的java.util.SQLException</td>
<td></td>
</tr>
</tbody></table>
<p>当不确定是什么语句的时候才应该使⽤execute()⽅法，否则应该使⽤executeQuery或者executeUpdate⽅法</p>
<hr>
<h2 id="7-JDBC中大数据量的分页解决方法？"><a href="#7-JDBC中大数据量的分页解决方法？" class="headerlink" title="7. JDBC中大数据量的分页解决方法？"></a>7. JDBC中大数据量的分页解决方法？</h2><p>使用sql语句进行分页，每次查询出的结果集中就只包含某页的数据内容</p>
<p>假设一共有38条数据，每页有10条数据，查询第3页的数据</p>
<p><strong>Oracle</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span>,rownum <span class="keyword">as</span> tempid <span class="keyword">from</span> student ) t</span><br><span class="line"><span class="keyword">where</span> t.tempid <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p><strong>mysql</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students limit <span class="number">20</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>sql server</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">10</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line">(<span class="keyword">select</span> top <span class="number">20</span> id <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> id) </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-在JDBC编程中处理事务的步骤？"><a href="#8-在JDBC编程中处理事务的步骤？" class="headerlink" title="8. 在JDBC编程中处理事务的步骤？"></a>8. 在JDBC编程中处理事务的步骤？</h2><p>事务是作为单个逻辑⼯作单元执⾏的⼀系列操作</p>
<p>⼀个逻辑⼯作单元必须有四个属性，称为原⼦性、⼀致性、隔离性和持久性(ACID) 属性</p>
<p>JDBC处理事务有如下操作：</p>
<ol>
<li>conn.setAutoComit(false);设置提交⽅式为⼿⼯提交。</li>
<li>conn.commit()提交事务。</li>
<li>conn.rollback()回滚事务。</li>
<li>提交与回滚只选择⼀个执⾏。正常情况下提交事务，如果出现异常，则回滚。</li>
</ol>
<hr>
<h2 id="9-说说数据库连接池工作原理和实现方案？"><a href="#9-说说数据库连接池工作原理和实现方案？" class="headerlink" title="9. 说说数据库连接池工作原理和实现方案？"></a>9. 说说数据库连接池工作原理和实现方案？</h2><p><strong>数据库连接</strong></p>
<ol>
<li>频繁的进行数据库连接耗时长、占用大量内存资源</li>
<li>对于未能关闭的连接将导致数据库系统的内存泄露，因而不得不重启数据库</li>
<li>创建的数据库连接过多，也可能导致内存泄漏，服务器崩溃</li>
</ol>
<p>因此数据库连接是⼀种关键的、有限的、昂贵的资源，对数据库连接的管理能显著影响到程序的性能指标</p>
<p><strong>数据库连接池</strong></p>
<p>数据库连接池负责分配、管理和释放数据库连接</p>
<p>它允许应⽤程序重复使⽤⼀个现有的数据库连接，⽽不是重新建⽴⼀个</p>
<p>释放空闲时间超过最⼤空闲时间的数据库连接来避免因为没有释放数据库连接⽽引起的数据库连接遗漏</p>
<p>数据库连接池在初始化时将创建⼀定数量的数据库连接放到连接池中，这些数据库连接的数量是由最⼩数据库连接数来设定的</p>
<p>⽆论这些数据库连接是否被使⽤，连接池都将⼀直保证⾄少拥有这么多的连接数量</p>
<p>连接池的最⼤数据库连接数量限定了这个连接池能占有的最⼤连接数，当应⽤程序向连接池请求的连接数超过最⼤连接数量时，这些请求将被加⼊到等待队列中。</p>
<p>其实我们查询完数据库后，如果不关闭连接，而是暂时存放起来，当别人使用时，把这个连接给他们使用。就避免了一次建立数据库连接和断开的操作时间消耗</p>
<p>解决资源的频繁分配﹑释放所造成的问题。基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。更为重要的是我们可以通过连接池的管理机制监视数据库的连接的数量﹑使用情况，为系统开发﹑测试及性能调整提供依据。</p>
<pre><code>①   编写class 实现DataSource 接口

   ②   在class构造器一次性创建10个连接，将连接保存LinkedList中

   ③   实现getConnection  从 LinkedList中返回一个连接

   ④   提供将连接放回连接池中方法
</code></pre>
<p><strong>工作原理：</strong>JAVA EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</p>
<p><strong>实现方案：</strong>返回的Connection是原始Connection的代理，代理Connection的close方法，当调用close方法时，不是真正关连接，而是把它代理的Connection对象放回到连接池中，等待下一次重复利用。</p>
<hr>
<h2 id="10-jdbc规范使用到设计模式？"><a href="#10-jdbc规范使用到设计模式？" class="headerlink" title="10. jdbc规范使用到设计模式？"></a>10. jdbc规范使用到设计模式？</h2><p>桥接模式，首先DriverManager获得Connection是通过反射和类加载机制从数据库驱动包的driver中拿到连接，所以这里真正参与桥接模式的是driver，而DriverManager和桥接模式没有关系，DriverManager只是对driver的一个管理器。而我们作为使用者只去关心Connection，不会去关心driver，因为我们的操作都是通过操作Connection来实现的。这样分析下来这个桥接就清晰了逻辑——java.sql.Driver作为抽象桥类，而驱动包如com.mysql.jdbc.Driver具体的实现桥接类，而Connection是被桥接的对象。</p>
<hr>
<h2 id="11-JDBC的事务管理是什么，为什么需要它？"><a href="#11-JDBC的事务管理是什么，为什么需要它？" class="headerlink" title="11. JDBC的事务管理是什么，为什么需要它？"></a>11. JDBC的事务管理是什么，为什么需要它？</h2><p>默认情况下，我们创建的数据库连接，是工作在自动提交的模式下的。这意味着只要我们执行完一条查询语句，就会自动进行提交。因此我们的每条查询，实际上都是一个事务，如果我们执行的是DML或者DDL，每条语句完成的时候，数据库就已经完成修改了。有的时候我们希望由一组SQL查询组成一个事务，如果它们都执行OK我们再进行提交，如果中途出现异常了，我们可以进行回滚。<br>JDBC接口提供了一个setAutoCommit(boolean flag)方法，我们可以用它来关闭连接自动提交的特性。我们应该在需要手动提交时才关闭这个特性，不然的话事务不会自动提交，每次都得手动提交。数据库 通过表锁来管理事务，这个操作非常消耗资源。因此我们应当完成操作后尽快的提交事务。在这里有更多关于事务的示例程序。</p>
<hr>
<h2 id="12-JDBC里的CLOB和BLOB数据类型分别代表什么？"><a href="#12-JDBC里的CLOB和BLOB数据类型分别代表什么？" class="headerlink" title="12. JDBC里的CLOB和BLOB数据类型分别代表什么？"></a>12. JDBC里的CLOB和BLOB数据类型分别代表什么？</h2><p>CLOB意思是Character Large OBjects，字符大对象，它是由单字节字符组成的字符串数据，有自己专门的代码页。这种数据类型适用于存储超长的文本信息，那些可能会超出标准的VARCHAR数据类型长度限制（上限是32KB）的文本。<br>BLOB是Binary Larget OBject，它是二进制大对象，由二进制数据组成，没有专门的代码页。它能用于存储超过VARBINARY限制（32KB）的二进制数据。这种数据类型适合存储图片，声音，图形，或者其它业务程序特定的数据。</p>
<hr>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
                <hr>
                

                <ul class="pager">
                    
                    
                    <li class="next">
                        <a href="/2024/03/22/多线程/" data-toggle="tooltip" data-placement="top"
                           title="多线程">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E4%B8%80%E4%B8%AA%E2%80%9C-java%E2%80%9D%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E7%B1%BB%EF%BC%88%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6"><span class="toc-text">20. 一个“.java”源文件中是否可以包含多个类（不是内部类）有什么限制?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAjava%E6%BA%90%E6%96%87%E4%BB%B6%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%90%8D%E7%A7%B0%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%90%97"><span class="toc-text">一个java源文件可以有名称相同，大小写不同的两个类吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D"><span class="toc-text">java可不可以使用中文命名?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E6%BA%90%E6%96%87%E4%BB%B6%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%95%B0%E5%AD%97%E5%BC%80%E5%A4%B4"><span class="toc-text">java源文件可以不可以数字开头?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#byte%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F"><span class="toc-text">byte的取值范围是多少，怎么计算出来的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#char-%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E5%82%A8%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">char 型变量中能不能存储一个中文汉字，为什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">&amp; 和 &amp;&amp; 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%972%E4%B9%98%E4%BB%A58%EF%BC%9F"><span class="toc-text">用最有效率的方法计算2乘以8？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="toc-text">Java移位运算符？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-0-1-0-3-%E5%B0%86%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88-true-%E8%BF%98%E6%98%AF-false"><span class="toc-text">3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#short-s1-1-s1-s1-1-%E6%9C%89%E9%94%99%E5%90%97-short-s1-1-s1-1-%E6%9C%89%E9%94%99%E5%90%97%EF%BC%9F"><span class="toc-text">short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1 有错吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8D%E7%9A%84%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-text">在 Java 中，如何跳出当前的多重嵌套循环？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-byte-%E4%B8%8A%EF%BC%8C%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8-long-%E4%B8%8A%EF%BC%8C%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8-String-%E4%B8%8A"><span class="toc-text">switch 是否能作用在 byte 上，能否作用在 long 上，能否作用在 String 上?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break-continue-return-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-text">break ,continue ,return 的区别及作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-text">Math类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Math-round-11-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%EF%BC%9FMath-round-11-5-%E5%8F%88%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="toc-text">Math.round(11.5)等于多少？Math.round(- 11.5) 又等于多少?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%96%E5%B0%8F%E6%95%B0%E7%82%B9%E5%89%8D%E4%B8%A4%E4%BD%8D%E5%B9%B6%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5"><span class="toc-text">如何取小数点前两位并四舍五入?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95%EF%BC%9FString%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">数组有没有length()方法？String有没有length()方法？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2-Integer-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83%E8%BE%93%E5%87%BA%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%BA%EF%BC%9F"><span class="toc-text">下面 Integer 类型的数值比较输出的结果为？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">int 和 Integer 有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">什么是方法的返回值？返回值的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E6%95%B0%E5%80%BC%E5%9E%8B%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%EF%BC%9F"><span class="toc-text">如何将数值型字符转换为数字？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%EF%BC%9F"><span class="toc-text">如何将数字转换为字符？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%BC%AA%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-text">如何理解Java中的泛型是伪泛型？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">注解的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B8%B8%E8%A7%81%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-text">42. 注解的常见分类？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-text">java面向对象的理解？面向对象的特征？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java中实现多态的机制是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">构造方法有哪些特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88constructor%EF%BC%89%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%89%EF%BC%9F"><span class="toc-text">构造器（constructor）是否可被重写（override）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">super关键字的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E4%B8%8Esuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">this与super的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java中重写和重载有哪些区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">接口和抽象类有哪些区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%EF%BC%88extends%EF%BC%89%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%EF%BC%88implements%EF%BC%89-%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%85%B7%E4%BD%93%E7%B1%BB%EF%BC%88concrete-class%EF%BC%89%EF%BC%9F"><span class="toc-text">接口是否可继承（extends）接口? 抽象类是否可实现（implements） 接口? 抽象类是否可继承具体类（concrete class）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">描述一下值传递和引用传递的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD-%E5%92%8Cequals%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java中&#x3D;&#x3D;和equals有哪些区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">hashCode()方法的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashCode-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E7%9A%84%E5%80%BC%E7%9B%B8%E5%90%8C%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E4%BB%AC%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">如果两个对象的hashCode()方法返回的值相同，那么它们是否相等？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0Java%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4hashCode-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">请简述Java中的默认hashCode()方法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0Java%E4%B8%AD%E7%9A%84equals-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">请简述Java中的equals()方法的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0Java%E4%B8%AD%E7%9A%84Objects-hash-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">请简述Java中的Objects.hash()方法的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0Java%E4%B8%AD%E7%9A%84Objects-toString-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">请简述Java中的Objects.toString()方法的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashcode%E6%96%B9%E6%B3%95%E5%92%8Cequals%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">hashcode方法和equals方法区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashcode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">为什么重写 equals 方法必须重写 hashcode 方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%80%BC%E7%9B%B8%E5%90%8C-x-equals-y-true-%EF%BC%8C%E4%BD%86%E5%8D%B4%E5%8F%AF%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84hash-code%EF%BC%8C%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%AF%B9%E4%B8%8D%E5%AF%B9%EF%BC%9F"><span class="toc-text">两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84-abstract-%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84-static-%EF%BC%8C-%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95-native-%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E8%A2%AB-synchronized%EF%BC%9F"><span class="toc-text">抽象的(abstract)方法是否可同时是静态的(static)， 是否可同时是本地方法(native)，是否可同时被 synchronized？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">final关键字的用法?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-final%E5%92%8Cstatic%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">60. final和static的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E4%B8%8Efinally%E3%80%81finalize-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">final与finally、finalize 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">静态变量和实例变量区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">静态方法和实例方法有何不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%87%BA%E4%B8%8B%E9%9D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-text">指出下面程序的运行结果？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6public-private-protected-%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%86%99%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">访问修饰符public,private,protected,以及不写（默认）时的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%9C%89%E6%B2%A1%E6%9C%89goto%EF%BC%9F"><span class="toc-text">Java有没有goto？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C-C-%E7%9A%84%E8%99%9A%E7%B1%BB%E7%9A%84%E7%9B%B8%E5%90%8C%E5%92%8C%E4%B8%8D%E5%90%8C%E5%A4%84"><span class="toc-text">Java 的接口和 C++的虚类的相同和不同处?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E6%98%AF%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97"><span class="toc-text">String 是最基本的数据类型吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">String、StringBuffer、StringBuilder区别及使用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-str-%E2%80%9Ci%E2%80%9D-%E5%92%8CString-str-new-String-%E2%80%9C1%E2%80%9D-%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="toc-text">String str &#x3D; “i” 和String str &#x3D; new String(“1”)一样吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BFString%E7%B1%BB%EF%BC%9F"><span class="toc-text">是否可以继承String类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-text">String s&#x3D;new String(“xyz”);创建了几个字符串对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">String类的常用方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E6%B2%A1%E6%9C%89-length-%E6%96%B9%E6%B3%95-String-%E6%9C%89%E6%B2%A1%E6%9C%89-length-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">数组有没有 length()方法?String 有没有 length()方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%B0%86-GB2312-%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA-ISO-8859-1-%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="toc-text">怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E4%B8%AD%E7%9A%84-equals-%E6%98%AF%E5%A6%82%E4%BD%95%E9%87%8D%E5%86%99%E7%9A%84%EF%BC%9F"><span class="toc-text">String 中的 equals 是如何重写的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%8D%E8%BD%AC%E5%8F%8A%E6%9B%BF%E6%8D%A2%EF%BC%9F"><span class="toc-text">如何实现字符串的反转及替换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E8%A6%81%E6%B1%82%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%EF%BC%8C%E5%AF%B9%E8%AF%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E5%88%86%E9%9A%94"><span class="toc-text">写一个函数，要求输入一个字符串和一个字符长度，对该字符串进行分隔</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C2-%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C1-%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C1-%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%88%AA%E5%8F%96%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%A6%81%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E4%B8%8D%E8%83%BD%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%EF%BC%9A%E5%A6%82%EF%BC%88%E2%80%9C%E6%88%91-ABC%E2%80%9D%EF%BC%8C4%EF%BC%89%E5%BA%94%E8%AF%A5%E6%88%AA%E4%B8%BA%E2%80%9C%E6%88%91-AB%E2%80%9D%EF%BC%8C%E8%BE%93%E5%85%A5%EF%BC%88%E2%80%9C%E6%88%91ABC-%E6%B1%89-DEF%E2%80%9D%EF%BC%8C6%EF%BC%89%E5%BA%94%E8%AF%A5%E8%BE%93%E5%87%BA%E4%B8%BA%E2%80%9C%E6%88%91-ABC%E2%80%9D%E8%80%8C%E4%B8%8D%E6%98%AF%E2%80%9C%E6%88%91-ABC-%E6%B1%89%E7%9A%84%E5%8D%8A%E4%B8%AA%E2%80%9D"><span class="toc-text">写一个函数，2 个参数，1 个字符串，1 个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我 ABC”，4）应该截为“我 AB”，输入（“我ABC 汉 DEF”，6）应该输出为“我 ABC”而不是“我 ABC+汉的半个”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BB%99%E5%87%BA%E9%9A%8F%E4%BE%BF%E5%A4%A7%E5%B0%8F%E7%9A%84-10-%E4%B8%AA%E6%95%B0%EF%BC%8C%E5%BA%8F%E5%8F%B7%E4%B8%BA-1-10%EF%BC%8C%E6%8C%89%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%87%BA%EF%BC%8C%E5%B9%B6%E8%BE%93%E5%87%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E5%BA%8F%E5%8F%B7"><span class="toc-text">用程序给出随便大小的 10 个数，序号为 1-10，按从小到大顺序输出，并输出相应的序号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95-%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%BB%9F%E8%AE%A1%E8%BF%99%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">写一个方法,输入一个文件名和一个字符串,统计这个字符串在这个文件中出现的次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BObject%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">介绍一下Object类中的方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashCode-%E5%92%8Cequals-%EF%BC%9F"><span class="toc-text">83. 为什么要重写hashCode()和equals()？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-Object%E7%B1%BB%E4%B8%ADfinalize-%E6%96%B9%E6%B3%95%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">84. Object类中finalize()方法作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-System-gc-%E5%92%8C-Runtime-gc-%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">85. System.gc() 和 Runtime.gc() 作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%EF%BC%9F"><span class="toc-text">86.  如何格式化日期？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87-%E6%89%93%E5%8D%B0%E6%98%A8%E5%A4%A9%E7%9A%84%E5%BD%93%E5%89%8D%E6%97%B6%E5%88%BB%E3%80%82"><span class="toc-text">87. 打印昨天的当前时刻。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%9F"><span class="toc-text">88. 如何在Java中生成随机数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F"><span class="toc-text">89. 什么是内部类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">90. 内部类的分类有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E5%AE%83%E7%9A%84%E5%8C%85%E5%90%AB%E7%B1%BB%EF%BC%88%E5%A4%96%E9%83%A8%E7%B1%BB%EF%BC%89%E7%9A%84%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6"><span class="toc-text">91. 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-Anonymous-Inner-Class-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%85%B6%E5%AE%83%E7%B1%BB%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">92. Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以 实现接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0%E4%B8%8B%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-text">93. 简单概述下异常。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="toc-text">94. 异常如何处理的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84throws%E3%80%81throw%E3%80%81try%E3%80%81catch%E3%80%81finally-%E5%88%86%E5%88%AB%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">95. 异常处理中的throws、throw、try、catch、finally 分别如何使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-try-%E9%87%8C%E6%9C%89%E4%B8%80%E4%B8%AA-return-%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B4%A7%E8%B7%9F%E5%9C%A8%E8%BF%99%E4%B8%AA-try-%E5%90%8E%E7%9A%84-finally-%E9%87%8C%E7%9A%84-code-%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%9C%A8-return-%E5%89%8D%E8%BF%98%E6%98%AF%E5%90%8E"><span class="toc-text">96. try{}里有一个 return 语句，那么紧跟在这个 try 后的 finally{}里的 code 会不会被执行，什么时候被执行，在 return 前还是后?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97-Error-%E5%92%8C-Exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">97. Error 和 Exception 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E5%BC%82%E5%B8%B8%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%9A%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-text">98. 异常编程题：下面代码的输出结果？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#99-%E7%B1%BB-Example-A-%E7%BB%A7%E6%89%BF-Exception%EF%BC%8C%E7%B1%BB-ExampleB-%E7%BB%A7%E6%89%BF-Example-A"><span class="toc-text">99. 类 Example A 继承 Exception，类 ExampleB 继承 Example A</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">100. 常见的异常有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-throw-%E5%92%8C-throws-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">101. throw 和 throws 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-Java-7-%E7%9A%84-try-with-resource"><span class="toc-text">102. Java 7 的 try-with-resource?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%BA%95%E5%B1%82%EF%BC%9F"><span class="toc-text">103. 异常的底层？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BB%80%E4%B9%88%E6%98%AFIO%E6%B5%81%EF%BC%9F"><span class="toc-text">104. 什么是IO流？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-Java-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81%EF%BC%9F"><span class="toc-text">105. Java 中有几种类型的流？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">106. 字节流和字符流的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#107-%E6%80%8E%E4%B9%88%E6%A0%B7%E6%8A%8A%E5%AD%97%E8%8A%82%E6%B5%81%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E6%B5%81-%E8%AF%B4%E5%87%BA%E5%AE%83%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-text">107. 怎么样把字节流转换成字符流,说出它的步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-text">108. 什么是序列化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#109-IO%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-text">109. IO如何实现序列化和反序列化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-PrintStream%E3%80%81BufferedWriter%E3%80%81PrintWriter-%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9F"><span class="toc-text">110. PrintStream、BufferedWriter、PrintWriter 的比较？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E5%A6%82%E6%9E%9C%E6%88%91%E8%A6%81%E5%AF%B9%E5%AD%97%E8%8A%82%E6%B5%81%E8%BF%9B%E8%A1%8C%E5%A4%A7%E9%87%8F%E7%9A%84%E4%BB%8E%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%8F%96-%E8%A6%81%E7%94%A8%E9%82%A3%E4%B8%AA%E6%B5%81-%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">111. 如果我要对字节流进行大量的从硬盘读取,要用那个流,为什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88"><span class="toc-text">112. 什么是集合?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">113. 集合框架中的泛型有什么优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-Iterator%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">114. Iterator是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#115-%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">115. 集合和数组的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#116-%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">116. 常用的集合类有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#117-Collection-%E5%92%8C-Collections-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">117. Collection 和 Collections 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-Set%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">118. Set和List的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#119-Arraylist%E4%B8%8E-LinkedList-%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-text">119. Arraylist与 LinkedList 异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#120-ArrayList%E5%92%8CVector%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%E7%82%B9%EF%BC%9F"><span class="toc-text">120. ArrayList和Vector有何异同点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AAList%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">121. 遍历一个List有哪些不同的方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-HashSet%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D%EF%BC%9F"><span class="toc-text">122. HashSet如何检查重复？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123-HashMap%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-text">123. HashMap如何遍历？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">124. HashMap 和 Hashtable 的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125-HashSet-%E5%92%8C-HashMap-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">125. HashSet 和 HashMap 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#126-HaspMap%E4%B8%8ETreeMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">126. HaspMap与TreeMap的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#127-ArrayList%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-text">127. ArrayList自动扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-ArrayList%E7%9A%84Fail-Fast%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">128. ArrayList的Fail-Fast机制？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Java-%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">13. Java 中的反射是什么意思？有哪些应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-text">14. 什么是反射？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%8F%8D%E5%B0%84%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%9F"><span class="toc-text">15. 反射的范围？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Class%EF%BC%9F"><span class="toc-text">16. 如何获取Class？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%8F%8D%E5%B0%84%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">17. 反射中常用的方法?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%88%A9%E4%B8%8E%E5%BC%8A"><span class="toc-text">18. 反射的利与弊?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-getName%E3%80%81getCanonicalName%E4%B8%8EgetSimpleName%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">19. getName、getCanonicalName与getSimpleName的区别?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDBC"><span class="toc-text">JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFJDBC%EF%BC%9F"><span class="toc-text">1. 什么是JDBC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Class-forName-com-mysql-cj-jdbc-Driver-%EF%BC%9F"><span class="toc-text">2. 如何理解Class.forName(com.mysql.cj.jdbc.Driver)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-JDBC%E7%9A%84DriverManager%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-text">3. JDBC的DriverManager是用来做什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AF%B4%E4%B8%8BJDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%846%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-text">4. 说下JDBC连接数据库的6个步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Statement-%E3%80%81PreparedStatement%E5%92%8CCallableStatement%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5. Statement 、PreparedStatement和CallableStatement的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-execute%EF%BC%8CexecuteQuery%EF%BC%8CexecuteUpdate%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">6. execute，executeQuery，executeUpdate的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-JDBC%E4%B8%AD%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%88%86%E9%A1%B5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">7. JDBC中大数据量的分页解决方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9C%A8JDBC%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-text">8. 在JDBC编程中处理事务的步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%B4%E8%AF%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">9. 说说数据库连接池工作原理和实现方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-jdbc%E8%A7%84%E8%8C%83%E4%BD%BF%E7%94%A8%E5%88%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">10. jdbc规范使用到设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-JDBC%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%83%EF%BC%9F"><span class="toc-text">11. JDBC的事务管理是什么，为什么需要它？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-JDBC%E9%87%8C%E7%9A%84CLOB%E5%92%8CBLOB%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">12. JDBC里的CLOB和BLOB数据类型分别代表什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text"></span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/ehazon">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/megahertz">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/haojen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/haojen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Haojen 2024
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/blog.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://haojen.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="">
</body>

</html>
