<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="马浩珍在 Github 上的个人博客">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="Haojen" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        Haojen&#39;s blog
        
    </title>

    <link rel="canonical" href="http://haojen.github.io/2024/03/22/权限管理框架/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/blog-style.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">

<meta name="generator" content="Hexo 7.1.1"></head>

<style>

    header.intro-header {
        background-image: url('//o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Haojen
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="">


<style>
    
    header.intro-header {
        background-image: url('')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1></h1>
                    
                    <span class="meta">
                         作者 Haojen Ma
                        <span>
                          日期 2024-03-22
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="Java权限管理框架面试题"><a href="#Java权限管理框架面试题" class="headerlink" title="Java权限管理框架面试题"></a>Java权限管理框架面试题</h1><h2 id="001什么是权限？"><a href="#001什么是权限？" class="headerlink" title="001什么是权限？"></a>001什么是权限？</h2><p>①权限管理：一般指根据系统设置的安全策略或者安全规则，用户可以访问而且只能访问自己被授权的资源，不多不少。权限管理几乎出现在任何系统里面，只要有用户和密码的系统。<br>②权限管理分类：<br>访问权限：管理员有增删改查权限，普通用户只有查询权限。<br>数据权限：管理员可以看到所有员工信息，但是员工只能看到自己的信息。</p>
<h2 id="002什么是认证？"><a href="#002什么是认证？" class="headerlink" title="002什么是认证？"></a>002什么是认证？</h2><p>身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和密码，看其是否与系统中存储的该用户的用户名和密码一致，来判断用户身份是否正确。例如：密码登录，手机短信验证、三方授权等。</p>
<h2 id="003Shiro框架用过吗？"><a href="#003Shiro框架用过吗？" class="headerlink" title="003Shiro框架用过吗？"></a>003Shiro框架用过吗？</h2><p>Apache Shiro是一个强大且易用的Java安全框架,能够非常清晰的处理认证、授权、管理会话以及密码加密。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。</p>
<h2 id="004Shiro的优点？"><a href="#004Shiro的优点？" class="headerlink" title="004Shiro的优点？"></a>004Shiro的优点？</h2><p>1.简单的身份验证，支持多种数据源<br>2.对角色的简单授权，支持细粒度的授权（方法）<br>3.支持一级缓存，以提升应用程序的性能<br>4.内置基于POJO的企业会话管理，适用于web及非web环境<br>5.非常简单的API加密<br>6.不跟任何框架绑定，可以独立运行</p>
<h2 id="005Shiro的核心组件"><a href="#005Shiro的核心组件" class="headerlink" title="005Shiro的核心组件?"></a>005Shiro的核心组件?</h2><p><strong>Subject：主体</strong>，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如爬虫、机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者。<br><strong>SecurityManager：安全管理器，</strong>即所有与安全有关的操作都会与SecurityManager交互，且它管理着所有Subject；可以看出它是shiro的核心, SecurityManager相当于spring mvc中的dispatcherServlet前端控制器。<br><strong>Realm：域</strong>，shiro从Realm获取安全数据(如用户、角色、权限)，就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色&#x2F;权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</p>
<h2 id="006Shiro认证执行流程？"><a href="#006Shiro认证执行流程？" class="headerlink" title="006Shiro认证执行流程？"></a>006Shiro认证执行流程？</h2><p>1)通过ini配置文件创建securityManager<br>2)调用subject.login方法主体提交认证，提交的token<br>3)securityManager进行认证，securityManager最终由ModularRealmAuthenticator进行认证。<br>4)ModularRealmAuthenticator调用IniRealm(给realm传入token) 去ini配置文件中查询用户信息<br>5)IniRealm根据输入的token（UsernamePasswordToken）从 shiro.ini查询用户信息，根据账号查询用户信息（账号和密码）<br>   如果查询到用户信息，就给ModularRealmAuthenticator返回用户信息（账号和密码）<br>   如果查询不到，就给ModularRealmAuthenticator返回null<br>6)ModularRealmAuthenticator接收IniRealm返回Authentication认证信息;<br>如果返回的认证信息是null，ModularRealmAuthenticator抛出异常（org.apache.shiro.authc.UnknownAccountException）<br>如果返回的认证信息不是null（说明inirealm找到了用户），对IniRealm返回用户密码 （在ini文件中存在）和 token中的密码 进行对比，如果不一致抛出异常（org.apache.shiro.authc.IncorrectCredentialsException）</p>
<h2 id="007Shiro授权执行流程？"><a href="#007Shiro授权执行流程？" class="headerlink" title="007Shiro授权执行流程？"></a>007Shiro授权执行流程？</h2><p>1)对subject进行授权，调用方法isPermitted（”permission串”）<br>2)SecurityManager执行授权，通过ModularRealmAuthorizer执行授权<br>3)ModularRealmAuthorizer执行realm（自定义的Realm）从数据库查询权限数据<br>调用realm的授权方法：doGetAuthorizationInfo<br>4)realm从数据库查询权限数据，返回ModularRealmAuthorizer<br>5)ModularRealmAuthorizer调用PermissionResolver进行权限串比对<br>6)如果比对后，isPermitted中”permission串”在realm查询到权限数据中，说明用户访问permission串有权限，否则 没有权限，抛出异常。</p>
<h2 id="008Shiro注解有哪些？"><a href="#008Shiro注解有哪些？" class="headerlink" title="008Shiro注解有哪些？"></a>008Shiro注解有哪些？</h2><p>1.@RequiresAuthentication : 表示当前Subject已经通过login进行了身份验证；即 Subject.isAuthenticated() 返回 true<br>2.@RequiresUser : 表示当前Subject 已经身份验证或者通过记住我登录的<br>3.@RequiresGuest : 表示当前Subject没有身份验证或通过记住我登陆过，即是游客身份<br>4.@RequiresRoles(value &#x3D; { “admin”, “user” }, logical &#x3D; Logical.AND) : 表示当前 Subject 需要角色 admin和user<br>5.@RequiresPermissions(value &#x3D; { “user:a”, “user:b” }, logical &#x3D; Logical.OR) : 表示当前 Subject 需要权限 user:a 或 user:b</p>
<h2 id="009SpringSecurity了解吗？"><a href="#009SpringSecurity了解吗？" class="headerlink" title="009SpringSecurity了解吗？"></a>009SpringSecurity了解吗？</h2><p>Spring Security在架构上将认证与授权分离，并提供了扩展点。它是一个轻量级的安全框架，它确保基于Spring的应用程序提供身份验证和授权支持。它与Spring MVC有很好地集成 ，并配备了流行的安全算法实现捆绑在一起。</p>
<h2 id="010SpringSecurity执行流程？"><a href="#010SpringSecurity执行流程？" class="headerlink" title="010SpringSecurity执行流程？"></a>010SpringSecurity执行流程？</h2><p>1.客户端发起一个请求，进入 Security 过滤器链。<br>2.当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理，如果登出失败则由 ExceptionTranslationFilter ；如果不是登出路径则直接进入下一个过滤器。<br>3.当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler 登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器。<br>4.当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层否则到 AccessDeniedHandler 鉴权失败处理器处理。</p>
<h2 id="011Shiro和SpringSecurity区别？"><a href="#011Shiro和SpringSecurity区别？" class="headerlink" title="011Shiro和SpringSecurity区别？"></a>011Shiro和SpringSecurity区别？</h2><p>1)Shiro比Spring Security更容易使用，也就是实现上简单一些，同时基本的授权认证Shiro也基本够用<br>2)Spring Security社区支持度更高，Spring社区的亲儿子，支持力度和更新维护上有优势，同时和Spring这一套的结合较好。<br>3)Shiro功能强大、且 简单、灵活。是Apache 下的项目比较可靠，且不跟任何的框架或者容器绑定，可以独立运行。</p>
<h2 id="012SpringSecurity如何解决跨域问题？"><a href="#012SpringSecurity如何解决跨域问题？" class="headerlink" title="012SpringSecurity如何解决跨域问题？"></a>012SpringSecurity如何解决跨域问题？</h2><p>SpringSecurity中提供了专业的方式来解决预检请求所面临的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                // 开启跨域配置</span><br><span class="line">                .cors()</span><br><span class="line">                .configurationSource(corsConfigurationSource())</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CorsConfigurationSource corsConfigurationSource() &#123;</span><br><span class="line">        // 提供CorsConfiguration实例，并配置跨域信息</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.setAllowedHeaders(Arrays.asList(&quot;*&quot;));</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(&quot;*&quot;));</span><br><span class="line">        corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:8081&quot;));</span><br><span class="line">        corsConfiguration.setMaxAge(3600L);</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cors()方法开启了对CorsConfigurer的配置，其最重要的方法就是configure方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                // 开启跨域配置</span><br><span class="line">                .cors()</span><br><span class="line">                .configurationSource(corsConfigurationSource())</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CorsConfigurationSource corsConfigurationSource() &#123;</span><br><span class="line">        // 提供CorsConfiguration实例，并配置跨域信息</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.setAllowedHeaders(Arrays.asList(&quot;*&quot;));</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(&quot;*&quot;));</span><br><span class="line">        corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:8081&quot;));</span><br><span class="line">        corsConfiguration.setMaxAge(3600L);</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到CorsFilter之后，调用http.addFilter方法将其添加到spring security过滤器链中，在过滤器链构建之前，会先对所有的过滤器进行排序，排序的依据在FilterOrderRegistration中已经定义好了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FilterOrderRegistration() &#123;</span><br><span class="line">    Step order = new Step(INITIAL_ORDER, ORDER_STEP);</span><br><span class="line">    put(ChannelProcessingFilter.class, order.next());</span><br><span class="line">    order.next(); // gh-8105</span><br><span class="line">    put(WebAsyncManagerIntegrationFilter.class, order.next());</span><br><span class="line">    put(SecurityContextPersistenceFilter.class, order.next());</span><br><span class="line">    put(HeaderWriterFilter.class, order.next());</span><br><span class="line">    put(CorsFilter.class, order.next());</span><br><span class="line">    put(CsrfFilter.class, order.next());</span><br><span class="line">    put(LogoutFilter.class, order.next());</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，CorsFilter的位置在HeaderWriterFilter之后，在CsrfFilter之前，这个时候还没到认证过滤器。Spring security根据开发者提供的CorsConfigurationSource对象构建出一个CorsFilter，并将该过滤器置于认证过滤器之前。</p>
<h2 id="013SpringSecurity如何对密码进行加密？"><a href="#013SpringSecurity如何对密码进行加密？" class="headerlink" title="013SpringSecurity如何对密码进行加密？"></a>013SpringSecurity如何对密码进行加密？</h2><p>Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 PasswordEncoder ，如果你想要自己实现一个加密算法的话，也需要继承 PasswordEncoder。<br>PasswordEncoder 接口一共也就 3 个必须实现的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface PasswordEncoder &#123;</span><br><span class="line"></span><br><span class="line">    // 加密也就是对原始密码进行编码</span><br><span class="line">    String encode(CharSequence var1);</span><br><span class="line"></span><br><span class="line">    // 比对原始密码和数据库中保存的密码</span><br><span class="line">    boolean matches(CharSequence var1, String var2);</span><br><span class="line"></span><br><span class="line">    // 判断加密密码是否需要再次进行加密，默认返回 false</span><br><span class="line">    default boolean upgradeEncoding(String encodedPassword) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方推荐使用基于 bcrypt 强哈希函数的加密算法实现类。</p>
<h2 id="014SpringSecurity如何优雅更换系统使用的加密算法？"><a href="#014SpringSecurity如何优雅更换系统使用的加密算法？" class="headerlink" title="014SpringSecurity如何优雅更换系统使用的加密算法？"></a>014SpringSecurity如何优雅更换系统使用的加密算法？</h2><p>推荐的做法是通过 DelegatingPasswordEncoder 兼容多种不同的密码加密方案，以适应不同的业务需求。<br>DelegatingPasswordEncoder 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0 之后，默认就是基于 DelegatingPasswordEncoder 进行密码加密的。</p>
<h2 id="015SpringSecurity有哪些控制请求访问权限的方法？"><a href="#015SpringSecurity有哪些控制请求访问权限的方法？" class="headerlink" title="015SpringSecurity有哪些控制请求访问权限的方法？"></a>015SpringSecurity有哪些控制请求访问权限的方法？</h2><p>● permitAll() ：无条件允许任何形式访问，不管你登录还是没有登录。<br>● anonymous() ：允许匿名访问，也就是没有登录才可以访问。<br>● denyAll() ：无条件决绝任何形式的访问。<br>● authenticated()：只允许已认证的用户访问。<br>● fullyAuthenticated() ：只允许已经登录或者通过 remember-me 登录的用户访问。<br>● hasRole(String) : 只允许指定的角色访问。<br>● hasAnyRole(String) : 指定一个或者多个角色，满足其一的用户即可访问。<br>● hasAuthority(String) ：只允许具有指定权限的用户访问<br>● hasAnyAuthority(String) ：指定一个或者多个权限，满足其一的用户即可访问。<br>● hasIpAddress(String) : 只允许指定 ip 的用户访问。</p>
<h2 id="016什么是单点登录？"><a href="#016什么是单点登录？" class="headerlink" title="016什么是单点登录？"></a>016什么是单点登录？</h2><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案 之一。SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<h2 id="017单点登录系统，如果cookie禁用，你们怎么解决"><a href="#017单点登录系统，如果cookie禁用，你们怎么解决" class="headerlink" title="017单点登录系统，如果cookie禁用，你们怎么解决?"></a>017单点登录系统，如果cookie禁用，你们怎么解决?</h2><p>如果禁用cookie可以使用url中带参数，把token传递给服务端。当然此方法涉及安全性问题，其实在cookie中保存token同样存在安全性问题。推荐使用sso框架CAS实现单点登录。</p>
<h2 id="018SSO原理（单点登录的过程）"><a href="#018SSO原理（单点登录的过程）" class="headerlink" title="018SSO原理（单点登录的过程）"></a>018SSO原理（单点登录的过程）</h2><p>以登录天猫为例进行说明：<br>1)当⽤户第⼀次访问淘宝的时候，因为还没有登录，会被引导到认证中⼼进⾏登录。<br>2)根据⽤户提供的登录信息，认证系统进⾏身份验证，如果通过，则登录成功，并返回给⽤户⼀个认证的凭据（JWT token）。<br>3)当⽤户访问天猫时，就会将这个 JWT token 带上，作为⾃⼰认证的凭据。<br>4)应⽤系统接收到请求后会把 JWT token 送到认证中⼼进⾏校验。<br>5)如果通过校验，⽤户就可以在不⽤再次登录的情况下访问天猫了。</p>
<h2 id="019SSO如何实现？"><a href="#019SSO如何实现？" class="headerlink" title="019SSO如何实现？"></a>019SSO如何实现？</h2><p>1)代理登录（agent）：用于无法改造的旧系统；<br>2)令牌环（token）：通过Cookie共享令牌环的方式传递当前用户信息，实现SSO，存在跨域问题；<br>3)身份票据（ticket）：除了增加一台信任验证服务器，完全满足了存储信任，验证信任，作用范围和安全性的问题，也是适用最广的webSSO实现方式</p>
<h2 id="020什么是CAS？"><a href="#020什么是CAS？" class="headerlink" title="020什么是CAS？"></a>020什么是CAS？</h2><p>CAS框架：CAS（Central Authentication Service，即：统一认证服务）是实现SSO单点登录的框架。CAS分为两部分，CAS Server和CAS Client。<br>CAS Server用来负责用户的认证工作，就像是把第一次登录用户的一个标识存在这里，以便此用户在其他系统登录时验证其需不需要再次登录。<br>CAS Client就是我们自己开发的应用程序，需要接入CAS Server端。当用户访问我们的应用时，首先需要重定向到CAS Server端进行验证，要是原来登陆过，就免去登录，重定向到下游系统，否则进行用户名密码登陆操作。</p>
<h2 id="021CAS中3个术语"><a href="#021CAS中3个术语" class="headerlink" title="021CAS中3个术语?"></a>021CAS中3个术语?</h2><p>Ticket Granting ticket (TGT) ：可以认为是CAS Server根据用户名密码生成的一张票，存在Server端<br>Ticket-granting cookie (TGC) ：其实就是一个Cookie，存放用户身份信息，由Server发给Client端<br>Service ticket (ST) ：由TGT生成的一次性票据，用于验证，只能用一次。相当于Server发给Client一张票，然后Client拿着这个票再来找Server验证，看看是不是Server签发的。</p>
<h2 id="022CAS处理流程"><a href="#022CAS处理流程" class="headerlink" title="022CAS处理流程?"></a>022CAS处理流程?</h2><p>1)用户访问网站，第一次来，重定向到 CAS Server，发现没有cookie，所以再重定向到CAS Server端的登录页面，并且URL带有网站地址，便于认证成功后跳转，形如 http ?&#x2F;cas-server:8100&#x2F;login?service&#x3D;http ?&#x2F;localhost:8081<br>注意：service后面这个地址就是登录成功后要重定向的下游系统URL。<br>2)在登陆页面输入用户名密码认证，认证成功后cas-server生成TGT，再用TGT生成一个ST。 然后再第三次重定向并返回ST和cookie(TGC)到浏览器<br>3)浏览器带着ST再访问想要访问的地址：<br>http ?&#x2F;localhost:8081&#x2F;?ticket&#x3D;ST-25939-sqbDVZcuSvrvBC6MQlg5<br>注意：ticket后面那一串就是ST<br>4)浏览器的服务器收到ST后再去cas-server验证一下是否为自己签发的，验证通过后就会显示页面信息，也就是重定向到第1步service后面的那个URL<br>首次登陆完毕。<br>5)再登陆另一个接入CAS的网站，重定向到CAS Server，server判断是第一次来（但是此时有TGC，也就是cookie，所以不用去登陆页面了），但此时没有ST，去cas-server申请一个于是重定向到cas-server，形如：http: &#x2F;&#x2F;cas-server:8100&#x2F;login?service&#x3D;http ?&#x2F;localhost:8082 &amp;&amp; TGC(cookie) (传目标地址和cookie）<br>6)cas-server生成了ST后重定向给浏览器http ?&#x2F;localhost:8082&#x2F;?ticket&#x3D;ST-25939-sqfsafgefesaedswqqw5-xxxx<br>7)浏览器的服务器收到ST后再去cas-server验证一下是否为自己签发的，验证通过后就会显示页面信息（同第4步）</p>
<h2 id="023什么是Token"><a href="#023什么是Token" class="headerlink" title="023什么是Token?"></a>023什么是Token?</h2><p>Token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。<br>当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。<br>简单Token的组成；uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。</p>
<h2 id="024OAuth是什么？"><a href="#024OAuth是什么？" class="headerlink" title="024OAuth是什么？"></a>024OAuth是什么？</h2><p>OAuth 是一个行业的标准授权协议，主要用来授权第三方应用获取有限的权限。实际上它就是一种授权机制，最终目的是为第三方应用颁发一个有时效性令牌 token，使得第三方应用能够通过该令牌获取相关的资源。<br>OAuth 2.0 比较常用的场景就是第三方登录，当你的网站接入了第三方登录时一般就是使用的 OAuth 2.0 协议。<br>现在OAuth 2.0也常见于支付场景（微信支付、支付宝支付）和开发平台（微信开放平台、阿里开放平台等等）。</p>
<h2 id="025介绍下Access-Token"><a href="#025介绍下Access-Token" class="headerlink" title="025介绍下Access Token ?"></a>025介绍下Access Token ?</h2><p>Access Token 是在 Oauth2.0 协议中，客户端访问资源服务器时需要带上的令牌（其实就是一段全局唯一的随机字符串）。拥有这个令牌代表着得到用户的授权。令牌里面包含哪个用户 在什么时候 授权给哪个app去做什么事情。当然这些信息是不能直接从Access Token 看出来的，而是存在平台方的数据库中，平台可以用Access Token 作为 key 去查询出这些信息，然后验证调用方是否有权限。</p>
<h2 id="026介绍下Refresh-Token"><a href="#026介绍下Refresh-Token" class="headerlink" title="026介绍下Refresh Token?"></a>026介绍下Refresh Token?</h2><p>Refresh Token是专用于刷新 Access Token 的 token。如果没有Refresh Token，也可以刷新 Access Token，但每次刷新都要用户输入登录用户名与密码。有了 Refresh Token，客户端直接用Refresh Token 去更新Access Token，无需用户进行额外的操作。</p>
<h2 id="027介绍下JWT？"><a href="#027介绍下JWT？" class="headerlink" title="027介绍下JWT？"></a>027介绍下JWT？</h2><p>Json Web Token (JWT)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。该token被设计为紧凑且安全，特别适用于分布式站点单点登录场景。<br>JWT由头部（header)、载荷（payload)、签证（signature) 三部分组成。</p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2024/03/22/设计模式/" data-toggle="tooltip" data-placement="top"
                           title="">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2024/03/22/开发工具/" data-toggle="tooltip" data-placement="top"
                           title="">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">Java权限管理框架面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#001%E4%BB%80%E4%B9%88%E6%98%AF%E6%9D%83%E9%99%90%EF%BC%9F"><span class="toc-text">001什么是权限？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#002%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A4%E8%AF%81%EF%BC%9F"><span class="toc-text">002什么是认证？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#003Shiro%E6%A1%86%E6%9E%B6%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">003Shiro框架用过吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#004Shiro%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">004Shiro的优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#005Shiro%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">005Shiro的核心组件?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#006Shiro%E8%AE%A4%E8%AF%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">006Shiro认证执行流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#007Shiro%E6%8E%88%E6%9D%83%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">007Shiro授权执行流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#008Shiro%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">008Shiro注解有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#009SpringSecurity%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">009SpringSecurity了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#010SpringSecurity%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">010SpringSecurity执行流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#011Shiro%E5%92%8CSpringSecurity%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">011Shiro和SpringSecurity区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#012SpringSecurity%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">012SpringSecurity如何解决跨域问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#013SpringSecurity%E5%A6%82%E4%BD%95%E5%AF%B9%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-text">013SpringSecurity如何对密码进行加密？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#014SpringSecurity%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%9B%B4%E6%8D%A2%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">014SpringSecurity如何优雅更换系统使用的加密算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#015SpringSecurity%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">015SpringSecurity有哪些控制请求访问权限的方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#016%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%9F"><span class="toc-text">016什么是单点登录？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#017%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%A6%82%E6%9E%9Ccookie%E7%A6%81%E7%94%A8%EF%BC%8C%E4%BD%A0%E4%BB%AC%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-text">017单点登录系统，如果cookie禁用，你们怎么解决?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#018SSO%E5%8E%9F%E7%90%86%EF%BC%88%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-text">018SSO原理（单点登录的过程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#019SSO%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">019SSO如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#020%E4%BB%80%E4%B9%88%E6%98%AFCAS%EF%BC%9F"><span class="toc-text">020什么是CAS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#021CAS%E4%B8%AD3%E4%B8%AA%E6%9C%AF%E8%AF%AD"><span class="toc-text">021CAS中3个术语?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#022CAS%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">022CAS处理流程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#023%E4%BB%80%E4%B9%88%E6%98%AFToken"><span class="toc-text">023什么是Token?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#024OAuth%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">024OAuth是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#025%E4%BB%8B%E7%BB%8D%E4%B8%8BAccess-Token"><span class="toc-text">025介绍下Access Token ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#026%E4%BB%8B%E7%BB%8D%E4%B8%8BRefresh-Token"><span class="toc-text">026介绍下Refresh Token?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#027%E4%BB%8B%E7%BB%8D%E4%B8%8BJWT%EF%BC%9F"><span class="toc-text">027介绍下JWT？</span></a></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/ehazon">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/megahertz">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/haojen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/haojen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Haojen 2024
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/blog.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://haojen.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="">
</body>

</html>
